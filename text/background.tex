\velocty can compile functions written in \matlab and NumPy to C++. In order to ensure that the code generated by \velocty matches the semantics of the language from which the code was generated, we first researched the semantics of the two languages. This chapter gives an overview of the semantics of the two languages that were important from the point of view of code generation.  Additionally, we used C APIs provided by \matlab, Python and NumPy to interface the generated code with the source language. The chapter also discusses the C APIs that were used by \velocty. Finally, the chapter describes the toolkits that were used by the compilation pipeline, namely the \mclab toolkit and the Velociraptor toolkit. 
\section{Comparison of \matlab and NumPy semantics}
Our compiler supports two languages, namely \matlab and NumPy. In order to ensure that the code generated matches the semantics of the language from which it was generated, we studied the semantics of both languages. This section discusses the similarities and differences of both languages. 
\subsection{\matlab}
\matlab supports 1-indexing, that is the array index starts from 1. 
The array layout is always column major. The number of dimensions are greater than or equal to 2. Row and column vectors are 1xn and nx1 matrices respectively whereas  scalars are 1x1 matrices. Function calls and array index operations have similar syntax as can be seen in Listing \ref{lst:index_mat1}. Line 2 is an array index operation on \textsf{A} and line 3 is a call to the function \textsf{sin}. 
\begin{lstlisting}[language=matlab, label={lst:index_mat1}, caption={An example of an array index operation and a function call.The array index operation and the function call have similar syntax. }]
A = zeros(3,3);
... = A(2,3);
...	= sin(A);
\end{lstlisting}

 \matlab allows the number of indices to be greater than the number of dimensions of the array as long as the values of all indices in positions higher than the number of dimensions are one. Listing \ref{lst:index_mat2} gives an example of an array with two dimensions each of size three and an index operation on the array with four indices. As we can observe, all indices at positions greater than the number of dimensions, that is two, are one and hence the index operation is valid.
\begin{lstlisting}[language=matlab, label={lst:index_mat2}, caption={An example of an array index operation where the number of indices are greater than the number of dimensions of the array}]
A = zeros(3,3);
... = A(2,3,1,1);
\end{lstlisting}
\matlab also allows  the number of indices to be less than the number of dimensions. We define this type of index operation as array flattening. Suppose we have an N-dimensional array A on which an index operation with K indices is performed. In this case, A can be treated as a K-dimensional array and the size of the K$^{th}$ dimension can be defined as 
\begin{equation}
Dim_K  = \prod_{i=k}^{N}{dim_i}
\end{equation}
where Dim$_K$ is the new K$^th$ and dim$_i$ is the i$^{th}$ dimension of the original array A. \\
Note that the dimensions of the array are not permanently modified but only for the purpose of the index operation.

\matlab also supports array slicing. Array slicing is an operation where a range of values can be provided in order to access a portion of the array instead of a single element. Listing \ref{lst:slice_mat} gives an example of the array slicing operation. The array A is 2-dimensional array with the sizes of the first and second dimensions as 4 and 3 respectively. The first index of the index operation on A contains a range with three values. The first value, 2 is known as the start value and gives the index from which the range starts. The second value is the step value, 2, which defines the interval between two indices and the third value is the stop value, 4, which defines the final index value. In this case the index values are 2 and 4 for the first index. In the case of the second index, the start, stop and step values are not provided. In this case, the start value is set to 1, the step value to 1 and the stop value to the size of the dimension. In this case, the second index refers to all the columns of the matrix. The index operation will return all the columns for the second and fourth row. The output will hence be a 2x3  matrix.
\begin{lstlisting}[language=matlab, label={lst:slice_mat}, caption={An example of an array slicing operation in \matlab}]
A = zeros(4,3);
... = A(2:2:4,:);
\end{lstlisting}

We define dimension-collapsing functions as those which perform an operation on a set of array elements and generate a single value. Thus the size of the output array differs from that of the input array. For example, the \textsf{sum} function in \matlab when given as input a matrix, treats the matrix as a row of column vectors and returns a row vector, where each element is the sum of the column elements of each column of the matrix. Other examples of dimension collapsing functions are \textsf{mean}, \textsf{max} and \textsf{min} etc. These functions also accept an optional parameter as input which defines the dimension along which the array has to be collapsed. 
\subsection{NumPy}
NumPy supports 0-indexing, that is the array index starts from 0. It also supports negative indexing, that is the index values can be negative. In the case of negative indexing, the index starts from the end of the array. For example, an index value \textsf{-1} refers to the last value of the dimension. The actual index value can be calculated by adding the size of the dimension to the index value. If the index value is -2 and the size of the dimension is n, the actual index is $n - 2$. NumPy supports column major, row major and strided array layouts. Strided layouts allow users to define their own array layout scheme. A NumPy array has one or more dimensions. Additionally, NumPy differentiates between arrays and scalars.

Unlike \matlab, Python does not allow the number of indices to be greater than the number of dimensions. The number of indices can be greater or less than the number of dimensions. If all the indices are numerical values and the number of indices are equal to the number of dimensions, a single value is returned. On the other hand, if the number of indices are less than the number of dimensions, a reference to the lower dimensions is returned. Line 3 in Listing \ref{lst:index_py} shows an index operation where the number of indices are equal to the number of dimensions. In this case, the element in the second row and first column is returned. On the other hand the index operation in line 4 contains one less index than the number of dimensions. In this case a reference to the second row is returned. Line 5 is an index operation with negative indexing. The first index -3 refers to the 1$^{st}$ row of the array.  Line 6 is a function call to the sin function. As we can see the syntax of the function call differs from that of an index operation which is unlike what we observe in \matlab. 

\begin{lstlisting}[float, language=python, label={lst:index_py}, caption={An example of indexing in NumPy}]
import numpy
A = numpy.zeros([4,3]);
= ... A[2,1]
= ... A[2]
= ... A[-3,2]
= ... numpy.sin(A)
\end{lstlisting}

Slicing operations in Python are similar to those of \matlab with the exception that the stop value is not included in the range of indices. Negative values in the ranges are also supported. Line 3 of Listing \ref{lst:slice_py} gives an example of array slicing in NumPy. Rows 3 and then 2 are selected and from each row the element in the second column is returned. Note that the range is specified different from \matlab. The step value is at the last position in the range whereas it is in between the start and stop values in \matlab. In this example, the start value is 3 and the stop value is 1. Note that Python does not throw an error if the start or stop values exceed dimensions. The values are merely modified to the smallest or largest valid value depending on whether the lower and the upper bounds are exceeded respectively. 
\begin{lstlisting}[float,language=python, label={lst:slice_py}, caption={An example of array slicing in NumPy}]
import numpy
A = numpy.zeros([4,3]);
... = A[3:1:-1,2]
\end{lstlisting}

Dimension collapsing functions in NumPy behave differently from those in \matlab. By default, the functions perform the operation on the entire array instead of only a set of elements. For example, the \textsf{sum} function will sum all the elements of the array and return a single value. If the output is to be collapsed against any dimension, the dimension has to be provided. 

\section{C APIs}
We used the C APIs provided by \matlab and Python to interface the generated code with the source language. To interface with \matlab, we use the MEX\cite{mex} API and the Python/C\cite{pyc} API is used for Python. 
\subsection{MEX}
The Mathworks' MEX provides functions and data structures to allow interfacing code in \matlab with code in C/C++. In order to use these functions, the \textsf{mex.h} header file is required to be included. A compiler to  compile the C/C++ code is also provided. Data between the \matlab code and the C++ code is passed as pointers to MxArrays. The raw array data and meta data can be accessed through different MEX functions. MEX also provides functions to create and destroy MxArrays as well as other basic memory management functions. Table \ref{tab:mexFunc} gives a list of MEX functions that are used for interfacing with the source langauge. 
\begin{table}[h]
\centering
\begin{tabular}{|c|c|}
\hline
MEX Functions           & Description                                                                                                                                                   \\ \hline
mxCreateNumericArray    & \begin{tabular}[c]{@{}c@{}}Creates an MxArray given dimensions, \\ number of dimensions, element type\\ and whether the array is real or complex\end{tabular} \\ \hline
mxCreateDoubleScalar    & \begin{tabular}[c]{@{}c@{}}Creates an MxArray with a single \\ element of type double.\end{tabular}                                                           \\ \hline
mxDestroyArray          & Frees memory allocated to the MxArray                                                                                                                         \\ \hline
mxMalloc                & Allocates memory of specified size in bytes                                                                                                                   \\ \hline
mxFree                  & Frees memory allocated by                                                                                                                                     \\ \hline
mxGetData               & \begin{tabular}[c]{@{}c@{}}Returns a void pointer to the raw array data\\ of a MxArray\end{tabular}                                                           \\ \hline
mxSetData               & \begin{tabular}[c]{@{}c@{}}Sets the mxArray's data pointer to given \\ memory.\end{tabular}                                                                   \\ \hline
mxSetDimensions         & \begin{tabular}[c]{@{}c@{}}Sets the dimensions and number of \\ dimensions of a mxArray\end{tabular}                                                          \\ \hline
mxGetDimensions         & Returns the dimensions of a mxArray                                                                                                                           \\ \hline
mxGetNumberOfDimensions & Returns the number of dimensions of a mxArray                                                                                                                 \\ \hline
\end{tabular}
\caption[List of MEX functions]{The table lists the MEX functions that were used by \velocty.}
\label{tab:mexFunc}
\end{table}

The entry point function for MEX has the name \textsf{mexFunction}. Every C/C++ program that is to be interfaced with \matlab is required to have an implementation of the  \textsf{mexFunction}. Listing \ref{lst:mexFunc} gives  the function signature of the \textsf{mexFunction}. The function takes four input parameters. The first parameter, \textsf{nlhs} defines the number of output parameters. The second parameter \textsf{plhs} is an array of mxArray pointers. \textsf{plhs} holds the output parameters of the function. The third and fourth parameters, \textsf{nrhs} and \textsf{prhs}, define the number of input parameters and the input parameters of the function. All elements of the plhs array are set to NULL and hence mxArrays need to be created in the C/C++ code before the function returns. On the other hand, prhs contains the input mxArrays that have been created by the calling function. 

\begin{lstlisting}[float,language=lisp, label={lst:mexFunc}, caption={Function signature of mexFunction}]
void mexFunction(int nlhs, mxArray *plhs[], int nrhs, 
  const mxArray *prhs[])
\end{lstlisting}

The C/C++ program can then be compiled using the MEX compiler. The compiler generates a dynamically linked library having the same name as the C/C++ source file. The MEX C/C++ function can then be called from a \matlab program as a regular \matlab function. 

\subsection{C APIs for Python}
Programs written in C/C++ can be interfaced with Python using the Python/C\cite{pyc} API. We also use the NumPy C-API\cite{numpyc} passing and returning arrays. The data structures and functions provided to interface with Python can be used by including the header file \textsf{Python.h}. In order to interface with Python code, the C/C++ has to be structured as a Python module. 
A Python program passes data to the C/C++ program as a single parameter, which is a pointer to a PyObject. If multiple parameters are to be passed into the function, the PyObject may represent an array of other PyObjects. Unlike MEX, there is no restriction on the name of the entry point function. Listing \ref{lst:pyFunc} gives an example of a C function which serves as an entry point function. The static function, arc\_distance, returns a pointer to a PyObject and take two input parameters, both PyObject pointers. The first input parameter, \textsf{self} is a pointer to the module object. The second parameter, \textsf{args} contains the input arguments of the function. 
\begin{lstlisting}[float,language=C, label={lst:pyFunc}, caption={Signature of a function that can be called from Python}]
  static PyObject* arc_distance(PyObject* self, PyObject *args); 
\end{lstlisting}

The methods that can be accessed from Python in the given module have to listed in an array of structs of the type PyMethodDef. PyMethodDef has four fields: method name as a string, pointer to the method implementation, METH\_VARGS which tells Python how to access the method and finally the documentation for the method. The last entry into the array should have all NULL values to indicate the end of the array. Listing \ref{lst:pyMethod} gives an example of the PyMethodDef array for the function arc\_distance. 
\begin{lstlisting}[language=C, label={lst:pyMethod}, caption={An Example of the PyMethodDef struct }]
static PyMethodDef arc_distance_kernelMethods[] =
   {
       {"arc_distance",arc_distance,METH_VARARGS,"arc_distance of a circle. "},
       {NULL,NULL,0,NULL}
   };
\end{lstlisting}

Additionally, a struct of type PyModuleDef also needs to be initialised. PyModuleDef describes the module. Listing \ref{lst:pyModule} gives an example of the PyModuleStruct for the module arc\_distance. The struct holds module information such as the name of the module, documentation and the PyMethodDef array among others.
\begin{lstlisting}[language=C, label={lst:pyModule}, caption={Example of the PyModuleDef struct}]
 static struct PyModuleDef arc_distance_kernelModule = {
       PyModuleDef_HEAD_INIT,
       "arc_distance_kernelModule",
       NULL,
       -1,
      arc_distance_kernelMethods,
  };
\end{lstlisting}

 Finally, the C/C++ program is required to implement the module initialisation function. Listing \ref{lst:pyInit} gives an example of the initialisation function. The name of the function is PyInit\_<module name>, that is \textsf{PyInit\_} followed by the name of the module. In this case the name of the module is arc\_distance. A module object is initialised using the method PyModule\_Create which takes the PyModuleDef struct as input. The function import\_array, is used to initialise NumPy specific constructs. 
\begin{lstlisting}[float,language=lisp, label={lst:pyInit}, caption={Example of the module initialisation function for the module arc\_distance}]
 PyMODINIT_FUNC
   PyInit_arc_distance_kernel(void){
        PyObject* m = PyModule_Create(&arc_distance_kernelModule);
       import_array();
       return m;
   }

\end{lstlisting}
\section{\mclab}
\mclab is an extensible compiler toolkit for \matlab. \mclab provides compilation, analysis and execution tools to optimise \matlab. \mclab provides frameworks to aid static compilation of \matlab programs to other languages such as FORTRAN and X10. These tools provide analyses which aid easy compilation of \matlab programs to different targets. McSAF, Tamer and Tamer+ are the three frameworks that are used for implementing static compilers for \matlab. 
\subsection{McSAF}
McSAF is a static analysis framework for implementing static analyses for the \matlab language. McSAF provides APIs and the core functionality to implement static analyses with ease. It also provides an intermediate representation known as McLAST on which the analyses and transformations can be performed. McLAST is a high-level AST\footnote{Abstract Syntax Tree} based representation with a structure close to the \matlab program from which it was generated. McSAF can be used for various purposes such as static compilation to static and dynamic languages, code refactoring etc. 

The kind analysis\cite{Doherty:2011:KAM:2076021.2048077}, implemented using McSAF, separates array index operations from function calls. This analysis is crucial because both array index operations and function calls are syntactically similarly and hence can not be differentiated statically based on syntax alone. 

The colon expression to range expression transformation was also performed using the McSAF framework. This transformation was a contribution on this thesis and is explained in Section \ref{sec:colonExpr}. 

Table \ref{tab:mcsaf} gives an example of a \matlab function babai, and the equivalent McSAF code that was generated. As we can observe, the generated McSAF code is very close to the original \matlab function. Through this framework we gather the information of the function calls and index operations of the function. Moreover, all the colon expressions have been converted to range expressions. 
\begin{table}[htbp]
\centering
\begin{tabular}{|l|l|}
\hline

\matlab & McSAF \\
\hline
{
\begin{lstlisting}[language=matlab,frame=none, numbers=none]
function z_hat = babai(R,y)
n=length(y);
z_hat=zeros(n,1);
z_hat(n)=round(y(n)./R(n,n));

for k=n-1:-1:1
    par=R(k,k+1:n)*z_hat(k+1:n);
    ck=(y(k)-par)./R(k,k);
    z_hat(k)=round(ck);
end

end

\end{lstlisting}
}
&
{
\begin{lstlisting}[language=matlab,frame=none, numbers=none]
function [z_hat] = babai(R, y)
  n = length(y);
  z_hat = zeros(n, 1);
  z_hat(n) = round((y(n) ./ R(n, n)));
  for k = ((n - 1) : (-1) : 1)
    par = (R(k, ((k + 1) : n)) * 
			z_hat(((k + 1) : n)));
    ck = ((y(k) - par) ./ R(k, k));
    z_hat(k) = round(ck);
  end
end
\end{lstlisting}

}
 \\
\hline
\end{tabular}
\caption[Example of a \matlab function and the equivalent McSAF code. ]{The table gives an example of a \matlab function babai and the generated McSAF code. }
\label{tab:mcsaf}
\end{table}
\subsection{Tamer}
Similar to McSAF, Tamer is an object oriented toolkit to implement analyses and transformations on \matlab. Tamer facilitates the static compilation of \matlab programs to different static languages. 

Given an entry point function, Tamer generates a complete callgraph. It also handles the large number of \matlab builtins through the Builtin framework.For every function in the callgraph, Tamer converts the function's McSAF intermediate representation, McLAST and generates Tame IR, a three address code\footnote{In a three address code based IR, each statement as at most three operands} based intermediate representation with specialised AST nodes. 

Tamer implements analyses on Tame IR which aids static compilation. These include the value analysis\cite{Dubrau:2012} which estimates \matlab types, the shape analysis\cite{Li:2014} which infers the dimensions of the variables and the IntegerOkay\cite{vkumar14} which identifies the variables having integer types. 

Table \ref{tab:tamer} gives an example of a \matlab function and the equivalent Tamer code. As we can see, since every statement is broken down into three address code, the length of the generated Tame IR code is quite large. Moreover, we can also observe that operators like \textsf{+} and \textsf{-} have been replaced by function calls. This is because in \matlab, operators are syntactic sugar and are replaced by function calls during execution. We get information about the type, the shape, that is the number of dimensions and the sizes of each dimensions of the variables in a function. We also get information about whether the variables are real or complex using the isComplex analysis\cite{iscmplx}. 

\begin{table}[htbp]
\centering
\begin{tabular}{|l|l|}
\hline

\matlab & McSAF \\
\hline
{
\begin{lstlisting}[language=matlab,frame=none, numbers=none]
function z_hat = babai(R,y)
n=length(y);
z_hat=zeros(n,1);
z_hat(n)=round(y(n)./R(n,n));

for k=n-1:-1:1
    par=R(k,k+1:n)*z_hat(k+1:n);
    ck=(y(k)-par)./R(k,k);
    z_hat(k)=round(ck);
end

end

\end{lstlisting}
}
&
{
\begin{lstlisting}[language=matlab,frame=none, numbers=none]
function  [z_hat] = babai(R, y)
  [n] = length(y);                    
  mc_t20 = 1;                        
  [z_hat] = zeros(n, mc_t20);        
  [mc_t3] = y(n);                    
  [mc_t4] = R(n, n);                 
  [mc_t2] = rdivide(mc_t3, mc_t4);   
  [mc_t0] = round(mc_t2);            
  z_hat(n) = mc_t0;                  
  mc_t21 = 1;                        
  [mc_t18] = minus(n, mc_t21);       
  mc_t22 = 1;                        
  [mc_t19] = uminus(mc_t22);         
  mc_t25 = 1;                        
  for k = (mc_t18 : mc_t19 : mc_t25);
    mc_t10 = k;                       
    mc_t23 = 1;                       
    [mc_t12] = plus(k, mc_t23);       
    mc_t13 = n;                       
    [mc_t11] = colon(mc_t12, mc_t13); 
    [mc_t5] = R(mc_t10, mc_t11);      
    mc_t24 = 1;                       
    [mc_t8] = plus(k, mc_t24);        
    mc_t9 = n;                        
    [mc_t7] = colon(mc_t8, mc_t9);    
    [mc_t6] = z_hat(mc_t7);           
    [par] = mtimes(mc_t5, mc_t6);     
    [mc_t16] = y(k);                  
    mc_t17 = par;                     
    [mc_t14] = minus(mc_t16, mc_t17); 
    [mc_t15] = R(k, k);               
    [ck] = rdivide(mc_t14, mc_t15);    
    [mc_t1] = round(ck);    
    z_hat(k) = mc_t1;        
  end
end
\end{lstlisting}

}
 \\
\hline
\end{tabular}
\caption[Example of a \matlab function and the equivalent Tame IR code.]{The Table gives an example of a \matlab function babai and the generated Tame IR code.}
\label{tab:tamer}
\end{table}
\subsection{Tamer+}
Tamer+ is a code aggregation framework. Since Tame IR is a three address code based IR, the code generated from Tame IR is long  and difficult for humans to read, due to the use of temporary variables. Hence, in order to improve code readability, Tamer+ aggregates multiple statements together and reduces the number of statements. Tamer+ takes as input Tame IR and outputs McSAF IR (McLAST). The generated code has fewer statements and is hence more readable. Tamer+ retains the information that was gathered through the analyses performed in Tamer. Tamer+ also generates a map from a sub-expression to its equivalent temporary if one exists. The type and shape information of the temporary would be the type and shape of the sub-expression. This map is therefore of importance to us as we will explain in the subsequent chapters. 

Table \ref{tab:tamer+} gives an example of a \matlab function and the equivalent McSAF code generated from Tame IR by Tamer+. The code length is almost the same as the original \matlab function. 
\begin{table}[htbp]
\centering
\begin{tabular}{|l|l|}
\hline

\matlab & McSAF(Generated by Tamer+) \\
\hline
{
\begin{lstlisting}[language=matlab,frame=none, numbers=none]
function z_hat = babai(R,y)
n=length(y);
z_hat=zeros(n,1);
z_hat(n)=round(y(n)./R(n,n));

for k=n-1:-1:1
    par=R(k,k+1:n)*z_hat(k+1:n);
    ck=(y(k)-par)./R(k,k);
    z_hat(k)=round(ck);
end

end

\end{lstlisting}
}
&
{
\begin{lstlisting}[language=matlab,frame=none, numbers=none]
function [z_hat] = babai(R, y)
  [n] = length(y);
  [z_hat] = zeros(n, 1);
  z_hat(n) = round(rdivide(y(n), R(n, n)));
  for k = (minus(n, 1) : uminus(1) : 1);
    [par] = mtimes(R(k, 
				colon(plus(k, 1), n)), 
			z_hat(colon(plus(k, 1), n)));
    [ck] = rdivide(minus(y(k), par)
				, R(k, k));
    z_hat(k) = round(ck);
  end
end
\end{lstlisting}

}
 \\
\hline
\end{tabular}
\caption[Example of a \matlab function and the equivalent McSAF code generated by Tamer+.]{The Table gives an example of a \matlab function babai and the generated McSAF code generated from Tame IR by Tamer+.}
\label{tab:tamer+}
\end{table}
\section{Velociraptor}
Velociraptor is a compiler toolkit aimed at improving performance of array-based languages such as \matlab and NumPy. The toolkit consists of an intermediate representation known as VRIR. The toolkit also provides various analysis on transformation on the IR. A compiler known as PyVrir, for Python to VRIR is also provided. 
\subsection{VRIR}
VRIR is high-level strongly typed AST based intermediate representation. VRIR is designed to be flexible to accommodate semantics of different scientific languages such as \matlab and Python's NumPy library. VRIR supports various array indexing schemes such as 0-indexing, 1-indexing and negative indexing and multiple array layouts such as row major, column major and stride major. VRIR also supports parallelism through constructs such as parallel for loop, map and reduce etc. VRIR can be generated as a string in the s-expression format which will then be converted to a C++ based AST. \velocty uses this approach in its compilation pipeline. Alternatively, the C++ AST can directly be generated.

\subsection{Parser}
If a language frontend compiling to VRIR, generates VRIR in the S-expression format and dumps it in a file, this file can be given to a parser implemented using ANTLR\cite{antlr}. The parser generates an ANTLR AST which is then converted into a C++ VRIR AST. This AST is then used for optimisations and code generation.  
\subsection{Analyses}
The Velociraptor toolkit also performs analyses and optimisations on VRIR which  can be reusable across compiler backends. The simplification pass simplifies expressions containing array operations into a three address code format. This simplification was useful to us while implementing the memory optimisation described in Section \ref{sec:memoptimise}. The preliminary bounds check eliminations analysis, identifies and eliminates redundant bounds checks.
