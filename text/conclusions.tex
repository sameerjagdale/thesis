\section{Conclusions}
The aim of the thesis was to improve performance of array based-languages by compiling computationally intensive code-sections to C++ and then compiling them to a shared library that can be called from the source array-based language. A partial compilation ensures that users can continue writing code in the source language. Another advantage of partial compilation is that portions of code which cannot be compiled ahead of time can be skipped. 

We used the Velociraptor toolkit for implementing the compiler. Velociraptor provides language agnostic tools and analyses to aid generation of high-performance code. The Velociraptor intermediate representation, VRIR, is a high-level AST based representation which has semantics that are close to those of array-based languages. This makes writing a front-end compiler to VRIR easy. Moreover, VRIR has flexible semantics to accomodate the semantic differences of different array-based languages. This allows us to write a single backend to compile from VRIR to C+++, which be used for multiple array-based languages. VRIR also contains constructs such as parallel for, map and reduce statements which can be used to generate parallel code. Additionally, Velciraptor provides analyses and transformations which aid in code generation. 

Contributions of this thesis can be divided into four parts. The first is the implementation of a frontend for the \matlab language. The frontend was impelemented using the open source \mclab toolkit. We faced challenges while compiling from a \matlab-specific intermediate representation to a language agnostic one. Determing the types of the expression nodes in VRIR and converting a colon expression to a range expression include some of them. The second is the generation of the glue code that is required to interface the generated code with \matlab. This involved the generation of code that converts \matlab-specific arrays to \velocty arrays, calling the generated function and finally converting the \velocty arrays back to the \matlab-specific array. The implementation of a compiler backend from VRIR to C++ is the third contribution of this thesis. The code generator was flexible enough to generate C++ code for the different semantics supported by VRIR. For example, the code generator can generate code for both row major and column major arrays. Additionally, we implemented runtime libraries for both \matlab and Python. These libraries implement different builtin functions supported by both languages, array bounds checks and array slicing operations among other functions. The final contribution of the thesis was to optimise the generated code. We implemented optimsations to eliminate bounds checks inside loop bodies and eliminated redundant unecessary memory allocations during array operations. Also, we supported naive parallelism using OpenMP.  

We observed significant gains in performance when comparing the generated code against the standard implementations for \matlab and Python, the Mathworks' \matlab interpreter and JIT compiler and the CPython interpreter respectively. We also observed gains over other tools for performance improvement for these languages such as the \matlab-coder for \matlab and Cython for NumPy.  

In conclusion, we would like to state that \velocty does achieve significant performance gains for both \matlab and NumPy. We believe that partial compilation improves usability by allowing users to continue compiling their preferred scientific language. Finally, our compiler backend is language agnostic and can help compiler writers improve performance of other languages such as R and Julia. \velocty is open source and freely available and hence can be reused and modified by researchers for their own research. 

\section{Future Work}
Although \velocty does achieve significant performance gains, there still is scope for improvement. We see five areas where improvement in performance may be achieved.
\subsection{GPU code generation}
Heterogenous architectures are gaining popularity in recent times. Many low-level languages and libraries have been developed for writing code for these architectures. These languages make good targets for high-performance compilers. An enhancement of \velocty could generation of GPU code from the parallel for loops. 
\subsection{Auto-parallelization}
\velocty currently supports naive parallelism. The user has to annotate the parallel for loops with a list of variables that are shared inside the loop. A possible improvement to \velocty would be implementation of algorithms that automatically identify loops which can be executed in parallel and identify the list of variables that are shared and ones that are private. Another improvement would be identification of statements that can be vectorised and replacing the statements by vector instructions. 
\subsection{Optimisations}
Many optimisations can be performed on the generated code to improve its performance. The \matlab frontend can be optimised to eliminate copy statements and copies of arrays  during function calls when the arrays are being written to. The bounds check optimisation can be improved to support a larger range of loops and indices. Additionally, operations on arrays can be made lazy and can only be performed when the array elements are accessed. This optimisation may lead to performance gains, since if a chain of array operations are performed, memory can be reused across operations. 
\subsection{Faster Builtins}
The builtin functions in the runtime libraries have naive implementations. Many techiniques such as parallelism and vector instructions can be used to improve the performance of these functions. 
\subsection{Readability}
The aim of the thesis was to ensure correct compilation of optimised code for \matlab and NumPy. In the future, we would like to add information to the generated code which would improve readability and simplify debugging of code. One approach could be to add the line numbers of the original code from which a certain code section has been generated. 
