A major goal of the thesis was to improve the performance of array-based languages like \matlab and Python's NumPy library by compiling computationally intensive functions to C++. To demonstrate these performance results, we compared the performance of the generated code with that provided by various tools for scientific computing. 17 \matlab benchmarks and 9 Python benchmarks were used to perform this comparision. Different variations of generated code that can be generated by turning optimisations on and off were also tested. 

In this chapter, we give a brief description of the benchmarks that were used to test the performance followed by the results themselves and our analysis of these results. 
\section{Benchmarks}
The \matlab benchmarks used for the performance were obtained from various sources. The sources include the FALCON project\cite{DeRose:1999} , the OTTER project \cite{quinn}, Chalmers university of technology\footnote{\url{http://www.elmagn.chalmers.se/courses/CEM/}}, Mathworks central file exchange\footnote{\url{http://www.mathworks.com/matlabcentral/fileexchange}} and the presentation on parallel programming in \matlab by Burkhadt and Cliff\footnote{\url{http://people.sc.fsu.edu/~jburkardt/presentations/matlab_parallel.pdf}}. The benchmarks cover commonly occurring \matlab features such as builtin function calls, array indexing including slicing operations and array operations like array addition, matrix multiplication, etc. Table \ref{tab:matBench} gives the list of benchmarks used along with their descriptions and source.  
\begin{table}[htbp]
\resizebox{\columnwidth}{!}{%
\centering
\begin{tabular}{|c|c|c|}
\hline
Benchmark  & Source               & Description\\
\hhline{|=|=|=|}
bbai       & MATLAB file exchange & Implementation of the Babai estimation algorithm \\
\hline 
bubl       & McLab                & Bubble Sort \\
\hline 
capr       & Chalmers University  & \begin{tabular}{@{} c@{}} Computes the capacitance of a transmission line \\ using fine difference and Gauss-seidel\end{tabular} \\
\hline 
clos       & Otter project        & Calculates the transitive closure of a directed graph \\
\hline 
crni       & Falcon project       & Crank-Nicholson solution to the heat equation \\
\hline
dich       & Falcon project       & Dirichlet solution to Laplace's equation\\
\hline
fiff       & Falcon project       & Computes the finite difference solution to the wave equation \\
\hline
ldgr       &                      & Calculates derivatives of Legendre polynomials \\
\hline
mbrt       & McFor project        & Computes Mandelbrot sets \\
\hline
nb1d       & Otter project        & Simulates the 1-dimensional n-body problem \\
\hline
matmul     & McLab                & naive matrix multiplication \\
\hline
mcpi       & McLab                & Calculates $\pi$ by the Monte Carlo method   \\
\hline
numprime   & Burkardt and Cliff   & \begin{tabular}{@{} c@{}} Simulates the sieve of Eratosthenes for  \\calculating number of prime numbers less than a given number \end{tabular} \\
\hline
scra       & ACM CALGO            & \begin{tabular}{@{} c@{}} Implementation to produce a reduced-rank \\ approximation to a matrix \end{tabular}   \\
\hline
spqr       & ACM CALGO            & \begin{tabular}{@{} c@{}} Implementation to compute a pivoted \\ semi-QR decomposition of an m-by-n matrix A \end{tabular} \\
\hline
quadrature & Burkardt and Cliff   &  \begin{tabular}{@{} c@{}} Simulates the quadrature approach \\ for  calculating integral of a function \end{tabular} \\
\hline
\end{tabular}
}
\caption{List of \matlab Benchmarks used for experiments}
\label{tab:matBench}
\end{table}

Many of the Python are python ports of the Ostrich benchmark suite\cite{Khan:2014:UJW:2661088.2661090}. The benchmarks contain scalar operations as well as array index operation. 6 of the 9 Python benchmarks support parallelism. Table \ref{tab:pyBenches} gives the list of Python benchmarks that were used.    % table for python benchmarks. 
\begin{table}[htbp]
\centering
\begin{tabular}{|c|c|c|}
\hline
Benchmark Name & Source    & Description                                                                                                                                              \\ 
\hhline{|=|=|=|}
arc\_distance  & PyBenches &                                                                                                                                                          \\ \hline
fft            & Pydwarfs  & Fast Fourier Transform                                                                                                                                   \\ \hline
growcut        & PyBenches &  Implementation of GrowCut segmentation                                                                                                                                                         \\ \hline
julia          & PyBenches &                                                                                                                                                          \\ \hline
lud            & PyDwarfs  & \begin{tabular}[c]{@{}c@{}}LU decomposition  factors a matrix as the product of a \\ lower triangular matrix and an upper triangular matrix\end{tabular} \\ \hline
pagerank       & PyDwarfs  & PageRank is a link analysis algorithm used by Google Search                                                                                              \\ \hline
pairwise       & PyBenches &                                                                                                                                                          \\ \hline
spmv           & PyDwarfs  & Sparse Matrix-Vector Multiplication                                                                                                                      \\ \hline
srad           & PyDwarfs  & \begin{tabular}[c]{@{}c@{}}Tracks the movement of a mouse heart over a sequence  of 104\\ 609x590 ultrasound images to record response to the stimulus \end{tabular} 
\\ \hline
\end{tabular}
\caption{List of Python Benchmarks used for experiments}
\label{tab:pyBenches}
\end{table}

\section{Experimental Setup}
We ran separate experiments for \matlab and Python benchmarks. The \matlab benchmarks were executed on the Mathworks' 2014b release of \matlab. We also used the Mathworks' Matlab-coder implementation to compile the benchmarks to C++ converted to a dynamic library similar to the method used by \velocty. In case of the Python benchmarks, we used the reference C-Python interpreter version 3.2.3  and Cython\cite{cython} version 0.21, which is a compiler used to generate C-extensions for Python.

Moreover, different variations of the code generated by \velocty were also tested. These variations include VeloCty code without optimisations and without bounds checks, C code with bounds checks but without optimisations, VeloCty code with bounds check optimisations, VeloCty code with memory optimisations and VeloCty code with OpenMP pragmas. The MEX compiler was used to compile the VeloCty code generated from \matlab to a shared library that could be called from \matlab. MEX internally uses the gcc-4.6.4 compiler. We use the gcc-4.6.4 compiler through distutils for compiling the VeloCty code generated from the Python benchmarks. 

All the benchmarks were tested on a machine running GNU/Linux(3.8.0-35-generic \#52-Ubuntu) with a Intel(R) Core(TM) i7-3820 CPU @ 3.60GHz with 16GB of memory. 
\section{Results}
This section describes the experimental results that were obtained for \matlab and Python.
\subsection{\matlab Results}
We ran experiments on 17 \matlab benchmarks. We compared the VeloCty backend without bounds checks with the Mathworks' \matlab implementation and \matlab-coder. We measured the speedup of the VeloCty backend and the \matlab-coder versions compared to  Mathwork's \matlab.Figure \ref{fig:results_cwochecks} shows a bar graph with the results of the experiment. The yellow bars show the speedup of \matlab-coder, the red bars show the speedup of VeloCty backend with array bounds checks enabled and the blue bars show the speedup of the VeloCty backend without the checks.. The geometric mean for the speedup of the VeloCty version was 6.17 as compared to the geometric mean of 3.89 for the \matlab-coder version. The largest speedup was shown by the quadrature benchmark. The benchmark was 318 times faster than Mathworks' \matlab. The benchmark consists of operations on scalar operations and hence gives a high speedup. The smallest speedup of 1.18, is given by the closure benchmark. The benchmark's computationally intensive code section is a while loop containing a matrix multiplication operation. All three versions, the VeloCty backend, Mathwork's \matlab and \matlab-coder use the Intel MKL BLAS library and hence show similiar performance. A VeloCty version of crni without checks was not generated because the benchmark contains a growing array and hence crashes if bounds checks are not enabled. 
\begin{figure}[htbp]
\centering
\includegraphics[scale=0.5]{Figures/results_cwochecks.png}
\caption{Experimental results for the VeloCty backend without checks}
\label{fig:results_cwochecks}
\end{figure}

For most benchmarks, our VeloCty backend was faster than \matlab-coder. The benchmarks, bbai, lgdr, nb1d, fft, scra and spqr are execptions. Bbai, scra and spqr showed poorer performance because of memory allocations from array operations performed inside a loop. Performance of these four benchmarks was improved due to the memory optimisation described in Section \ref{sec:memoptimise}. Lgdr and nb1d contain array slicing and array operations which do not internally make calls to the BLAS library and hence take longer to execute compared to \matlab-coder. The fft benchmark contains a loop whose direction can not be identified at run time and hence a loop vector needs to be initialised and iterated over as described in Subsection \ref{subsec:forStmt}. 

As we can also observe \matlab-coder is shows a positive speedup on all benchmarks except for mcpi. The reason for this is that the benchmark contains a loop with random function calls inside the body. These functions return a single scalar value. However, in case of \matlab-coder, an 1x1 matrix is returned. Since a heap allocation is needed for every iteration, the benchmark is significantly slower than Mathworks' \matlab. 

When comparing the execution times of the VeloCty backend with and without bounds checks, we observed that the execution times of benchmarks containing array slicing or array operations were not affected by turning the checks on. On the other hand, benchmarks consisting of simple indexing operations show a larger slowdown when array bounds checks were turned on. As we can see, 6 of the 17 benchmarks show a slow down when bounds check are added. The benchmarks include fft, fiff, matmul, bubble, capr and dich. 

Table \ref{tab:CwovsCw} gives the slowdown of the generated VeloCty code when bounds checks are enabled compared to when bounds checks are disabled. The geometric mean of the slowdown for all benchmarks is 1.65. If only the geometric mean of the affected benchmarks are considered, we get a geometric mean of 3.66. The matmul benchmark shows the highest slowdown with 10.44. The slowdown for the crni benchmark cannot be calculated since a version of the generated code with checks disabled cannot be executed. 

\begin{table}[htbp]
\centering
\begin{tabular}{|c|c|}
\hline
Benchmarks                           & Slowdown     \\ \hhline{|=|=|}
bbai                                 & 1.210019268  \\ \hline
bubble                               & 8.613793103  \\ \hline
capr                                 & 2.62406015   \\ \hline
clos                                 & 0.8444354184 \\ \hline
crni                                 & -            \\ \hline
dich                                 & 1.711805556  \\ \hline
fft                                  & 1.436065574  \\ \hline
fiff                                 & 4.15234375   \\ \hline
lgdr                                 & 1.016372796  \\ \hline
matmul                               & 10.44827586  \\ \hline
mbrt                                 & 1.021621622  \\ \hline
mcpi                                 & 1.003021148  \\ \hline
nb1d                                 & 1.047817048  \\ \hline
numprime                             & 1.061643836  \\ \hline
quadrature                           & 1            \\ \hline
scra                                 & 1.098253275  \\ \hline
spqr                                 & 1.037181996  \\ \hline
Geometric mean                       & 1.657669836  \\ \hline
Geometric mean (Affected Benchmarks) & 3.661753813  \\ \hline
\end{tabular}
\caption{Slowdown of the Generated VeloCty Code when Bounds Checks are enable compared to when Bounds Checks are disabled}
\label{tab:CwovsCw}
\end{table}
In order to determine the improvement in performance when bounds check optimisations were enabled, we compared the slowdown of the generated VeloCty code with checks enabled  and the slowdown of the generated code with the bounds check optimisation enabled against the generated VeloCty code without checks. Table \ref{tab:CwvsCbc} gives the slowdowns for all the benchmarks. The geometric mean of slowdown with the optimisation enabled is 1.01. Thus the version of the generated code with optimisations enabled is as fast as the version without checks. 
\begin{table}[htbp]
\centering
\begin{tabular}{|c|c|c|}
\hline
Benchmarks                           & VeloCty with checks & VeloCty with optimisation \\ \hhline{|=|=|=|}
bbai                                 & 1.210019268   & 1.134874759         \\ \hline
bubble                               & 8.613793103   & 1.006896552         \\ \hline
capr                                 & 2.62406015    & 0.7218045113        \\ \hline
clos                                 & 0.8444354184  & 0.9126726239        \\ \hline
crni                                 & -             & -                   \\ \hline
dich                                 & 1.711805556   & 1                   \\ \hline
fft                                  & 1.436065574   & 1.426229508         \\ \hline
fiff                                 & 4.15234375    & 0.96875             \\ \hline
lgdr                                 & 1.016372796   & 1.057934509         \\ \hline
matmul                               & 10.44827586   & 0.9913793103        \\ \hline
mbrt                                 & 1.021621622   & 1.021621622         \\ \hline
mcpi                                 & 1.003021148   & 1.001007049         \\ \hline
nb1d                                 & 1.047817048   & 0.9875259875        \\ \hline
numprime                             & 1.061643836   & 1.071917808         \\ \hline
quadrature                           & 1             & 1                   \\ \hline
scra                                 & 1.098253275   & 0.9825327511        \\ \hline
spqr                                 & 1.037181996   & 1.084148728         \\ \hline
Geometric mean                       & 1.657669836   & 1.014442695         \\ \hline
Geometric mean (Affected Benchmarks) & 3.661753813   & 0.9992501872        \\ \hline
\end{tabular}
\caption{Slowdown of generated VeloCty code with checks and generated VeloCty code with bounds check optimisation. }
\label{tab:CwvsCbc}
\end{table}

The performance improvement of the generated code when the memory optimisations were enabled was also gauged. We calculated the speedups of the generated VeloCty code with memory optimisations enabled compared to the generated VeloCty code without checks for all the benchmarks. Table \ref{tab:cmvscwo} gives the speedups for the benchmarks. The geometric mean of the speedups for all benchmarks is 1.14. Four benchmarks, capr, scra, spqr and nb1d showed speedups of 1.4, 3.24, 2.67 and 1.51 respectively. The geometric mean of the four affected benchmarks is 2.36. 
\begin{table}[htbp]
\centering
\begin{tabular}{|c|c|}
\hline
Benchmarks                           & VeloCty with memory optimisation \\ \hhline{|=|=|}
bbai                                 & 0.9980769231               \\ \hline
bubble                               & 1.013986014                \\ \hline
capr                                 & 1.4                        \\ \hline
clos                                 & 1.18479307                 \\ \hline
crni                                 & -                          \\ \hline
dich                                 & 0.9632107023               \\ \hline
fft                                  & 0.9945652174               \\ \hline
fiff                                 & 1.003921569                \\ \hline
lgdr                                 & 1.065057009                \\ \hline
matmul                               & 1.01754386                 \\ \hline
mbrt                                 & 0.9762532982               \\ \hline
mcpi                                 & 0.993993994                \\ \hline
nb1d                                 & 1.517350158                \\ \hline
numprime                             & 0.9449838188               \\ \hline
quadrature                           & 1                          \\ \hline
scra                                 & 3.24822695                 \\ \hline
spqr                                 & 2.67539267                 \\ \hline
Geometric mean                       & 1.142948856                \\ \hline
Geometric mean (Affected Benchmarks) & 2.362507726                \\ \hline
\end{tabular}
\caption{Speedups of Generated VeloCty code with Memory Optimisations}
\label{tab:cmvscwo}
\end{table}

Three of the \matlab benchmarks, nb1d, matmul and mbrt can be executed in parallel. We calculated the speedups of the three benchmarks in parallel compared to the VeloCty version without checks. Table \ref{tab:cpvscwo} gives the speedups for the three benchmarks. The matmul and mbrt benchmarks show significant speedups. This is because in the case of the the two benchmarks, a very small portion of the code needs to be executed sequentially. Moreover, parallel portion of the code is computationally intensive thus making the thread management time a small portion of the total execution time. On the other hand, the nb1d benchmark shows no speedup. This can be attributed to the fact that the loop being parallelised is nested inside another loop executing sequentially. Moreover, the loop being executed in parallel in not computationally intensive and hence the benchmark does not benefit from parallel execution. 
\begin{table}[htbp]
\centering
\begin{tabular}{|c|c|}
\hline
Benchmark & Speedup \\ \hhline{|=|=|}
matmul    & 4.75    \\ \hline
mbrt      & 3.19    \\ \hline
nb1d      & 0.96    \\ \hline
\end{tabular}
\caption{Speedup of Generated Code with Parallel constructs}
\label{tab:cpvscwo}
\end{table}

We also calculated the speedup of the generated VeloCty code with all optimisations enabled compared to the generated VeloCty code without checks. The geometric mean of the speedup compared to the VeloCty code without checks is 1.28. The maximum speedup compared to that of  3.16 is given by the matmul benchmark. Not all benchmarks show significant speedups. The performance of such of benchmarks can be improved by optimising the builtin implementations provided by the runtime library.

We observed higher speedups of the generated VeloCty code with all optimisations enabled compared to the generated VeloCty code with checks enabled. This is because the bounds check optimisation improves peformance of the benchmarks compared to the benchmark versions when the checks are enabled. The geometric mean of the speedup is 2.15. The highest speedup of 24.24 is observed for the matmul benchmark. The matmul benchmark benefits from the boundscheck optimisation as well as parallel code generation. Table \ref{tab:covscwcwo} shows the speedups for the generated VeloCty code with all optimisations enabled compared to both the VeloCty code with checks and without checks. 
\begin{table}[htbp]
\centering
\begin{tabular}{|c|c|c|}
\hline
\multirow{2}{*}{Benchmarks} & \multicolumn{2}{c|}{Speedups}                                                                                                                                \\ \cline{2-3} 
                            & \begin{tabular}[c]{@{}c@{}}compared to VeloCty backend\\ without Checks\end{tabular} & \begin{tabular}[c]{@{}c@{}}Compared to VeloCty backend\\ with Checks\end{tabular} \\ \hhline{|=|=|=|}
bbai                        & 1.023668639                                                                    & 1.238658777                                                                 \\ \hline
bubble                      & 0.9666666667                                                                   & 8.326666667                                                                 \\ \hline
capr                        & 0.9637681159                                                                   & 2.528985507                                                                 \\ \hline
clos                        & 1.235323633                                                                    & 1.043151029                                                                 \\ \hline
crni                        & -                                                                              & 2.523006135                                                                 \\ \hline
dich                        & 1.028571429                                                                    & 1.760714286                                                                 \\ \hline
fft                         & 0.6596971882                                                                   & 0.9473684211                                                                \\ \hline
fiff                        & 0.7252124646                                                                   & 3.011331445                                                                 \\ \hline
lgdr                        & 1.11048951                                                                     & 1.128671329                                                                 \\ \hline
matmul                      & 2.32                                                                           & 24.24                                                                       \\ \hline
mbrt                        & 3.162393162                                                                    & 3.230769231                                                                 \\ \hline
mcpi                        & 0.9969879518                                                                   & 1                                                                           \\ \hline
nb1d                        & 1.551612903                                                                    & 1.625806452                                                                 \\ \hline
numprime                    & 1.03180212                                                                     & 1.09540636                                                                  \\ \hline
quadrature                  & 1                                                                              & 1                                                                           \\ \hline
scra                        & 2.775757576                                                                    & 3.048484848                                                                 \\ \hline
spqr                        & 2.647668394                                                                    & 2.74611399                                                                  \\ \hline
Geometric mean              & 1.28520656                                                                     & 2.151747961                                                                 \\ \hline
\end{tabular}
\caption{Speedup of generated VeloCty code with all optimisations enabled compared to VeloCty code without optimisations and with and without bounds checks enabled.}
\label{tab:covscwcwo}
\end{table}
\subsection{Python Results}
We ran experiments on 9 Python benchmarks. We compared the generated VeloCty code without bounds checks to Cython and the CPython interpreter. Figure \ref{fig:results_cwochecks_py} is a bar graph showing the speedup of the generated VeloCty code with checks disabled, the generated VeloCty code with checks enabled and the Cython code compared to the CPython interpreter. The blue bars indicate the speedup of the generated VeloCty code without checks, the red bars indicate the speedup of the generated VeloCty code with checks enabled and the yellow bars indicate the speedup of the Cython code. The geometric mean of the speedups for the generated VeloCty code without checks was 208.69. The largest speedup of 557.82  was shown by the lud benchmark. The smallest speedup of 47.11 was shown by the fft benchmark. The geometric mean of the speedups of the generated VeloCty code with the checks enabled was 164.48. The highest speedup of 538.3 was shown by the lud benchmark. The smallest speedup, 43.01 was shown by the fft benchmark. 
\begin{figure}[htbp]
\centering
\includegraphics[scale=0.5]{Figures/results_cwochecks_py.png}
\caption{Comparison of the speedups of the generated VeloCty code with and without checks and Cython.}
\label{fig:results_cwochecks_py}
\end{figure}

The generated VeloCty code without is faster than the Cython code for all the benchmarks. Comparing the speedup of our generated VeloCty code to the Cython code, a mean speedup of 2.21 was found. The largest speedup of 14.93 was shown by the fft benchmark. The benchmarks arc\_distance, lud and pagerank take the same time to execute as our generated C++ code. All three benchmarks have fewer array index operations and more scalar operations compared to the other benchmarks. On the other hand the fft benchmark performs significantly better for the generated VeloCty code than the Cython version. The fft benchmark contains recursive function calls. Cython adds checks to ensure validity of the input arguments of a function as well as validity of the arguments being passed from the function call point. 

Enabling array bounds checks gives a significant slowdown in 4 of the 9 benchmarks. These benchmarks are growcut, pairwise, spmv and srad. Table \ref{tab:cwvscwopy} lists the slowdowns observed for the generated VeloCty versions with checks enabled compared to the generated VeloCty version with checks disabled. The geometric mean of the slowdown is 1.27. The highest slowdown was shown by the pairwise benchmark. Benchmarks which were not affected by array bounds checks enabled were ones which contained loops with fewer loop iterations or with fewer array index operations in their bodies. 
\begin{table}[htbp]
\centering
\begin{tabular}{|c|c|}
\hline
Benchmarks     & Slowdown    \\ \hhline{|=|=|}
arc\_distance  & 1.023523262 \\ \hline
fft            & 1.095238095 \\ \hline
growcut        & 1.285714286 \\ \hline
julia          & 1.012594458 \\ \hline
lud            & 1.03626943  \\ \hline
pagerank       & 1.019169329 \\ \hline
pairwise       & 1.940577998 \\ \hline
spmv           & 1.734177215 \\ \hline
srad           & 1.642801633 \\ \hline
Geometric mean & 1.268792366 \\ \hline
Geometric mean(Affected Benchmarks)  &  1.63 \\ \hline
\end{tabular}
\caption{Slowdown of the Python benchmarks for VeloCty code with checks enabled compared to VeloCty code without checks}
\label{tab:cwvscwopy}
\end{table}

We also timed versions of the generated VeloCty code with the bounds check optimisations enabled. We compared the slowdown of the VeloCty code with bounds check optimisations with the VeloCty code without checks and the slowdown of the VeloCty code with checks enabled. Table \ref{tab:cwvscopy} lists slowdowns for all the python benchmarks. The geometric mean of slowdown for the VeloCty code with optimisation is 0.96. That is, the version of VeloCty with bounds check optimisation is as fast the version without checks.
\begin{table}[htbp]
\centering
\begin{tabular}{|c|c|c|}
\hline
\multirow{2}{*}{Benchmarks} & \multicolumn{2}{c|}{Slowdown}                                                                             \\ \cline{2-3} 
                            & VeloCty code with checks & \begin{tabular}[c]{@{}c@{}}VeloCty code with bounds \\ check optimisation\end{tabular} \\ \hhline{|=|=|=|}
arc\_distance               & 1.023523262          & 0.9968733715                                                                       \\ \hline
fft                         & 1.095238095          & 0.9483870968                                                                       \\ \hline
growcut                     & 1.285714286          & 0.8279569892                                                                       \\ \hline
julia                       & 1.012594458          & 1.001261034                                                                        \\ \hline
lud                         & 1.03626943           & 0.9796954315                                                                       \\ \hline
pagerank                    & 1.019169329          & 0.9968152866                                                                       \\ \hline
pairwise                    & 1.940577998          & 1.032397408                                                                        \\ \hline
spmv                        & 1.734177215          & 0.9186046512                                                                       \\ \hline
srad                        & 1.642801633          & 0.9736842105                                                                       \\ \hline
Geometric mean              & 1.268792366          & 0.9621734128                                                                       \\ \hline
\end{tabular}
\caption{Slowdown of VeloCty with check optimisation and VeloCty with checks enabled.}
\label{tab:cwvscopy}
\end{table}

6 of the 9 benchmarks could be executed in parallel. We calculated the speedups of the VeloCty versions executing in parallel with the VeloCty version without array checks. The geometric mean of the speedups was 3.12. Maximum speedup was observed in the pairwise benchmark. The benchmark showed a speedup of 4.19. The smallest speedup of 2.5  was observed by the srad benchmark. Table \ref{tab:cpvscwopy} gives the speedups for the 6 benchmarks that could be executed in parallel.
\begin{table}[h]
\centering
\begin{tabular}{|c|c|}
\hline
Benchmarks     & Speedups    \\ \hhline{|=|=|}
growcut        & 3.347826087 \\ \hline
lud            & 2.718309859 \\ \hline
pagerank       & 3.068627451 \\ \hline
pairwise       & 4.192982456 \\ \hline
spmv           & 3.16        \\ \hline
srad           & 2.5         \\ \hline
Geometric mean & 3.121471389 \\ \hline
\end{tabular}
\caption{Speedups of the VeloCty parallel version compared to the VeloCty version without checks}
\label{tab:cpvscwopy}
\end{table}
\begin{table}[htbp]
\centering
\begin{tabular}{|c|c|c|}
\hline
\multirow{2}{*}{Benchmarks} & \multicolumn{2}{c|}{Speedups}                \\ \cline{2-3} 
                            & v/s VeloCty without Checks & v/s VeloCty with Checks \\ \hhline{|=|=|=|}
arc\_distance               & 1.006312467            & 1.029984219         \\ \hline
fft                         & 0.8698224852           & 0.9526627219        \\ \hline
growcut                     & 2.483870968            & 3.193548387         \\ \hline
julia                       & 0.9887920299           & 1.00124533          \\ \hline
lud                         & 2.643835616            & 2.739726027         \\ \hline
pagerank                    & 3.068627451            & 3.12745098          \\ \hline
pairwise                    & 3.886178862            & 7.54                 \\ \hline
spmv                        & 2.025641026            & 3.512820513         \\ \hline
srad                        & 2.151162791            & 3.533933745         \\ \hline
Geometric mean              & 1.881731624            & 2.38795278          \\ \hline
\end{tabular}
\caption{Speedups of VeloCty version with all optimisations compared to VeloCty versions with and without bounds checks}
\label{tab:copvscwopy}
\end{table}

Finally, we calculated the speedups of the VeloCty version with all optimisations enabled and compared them to both the VeloCty version without checks and the version with checks. Table \ref{tab:copvscwopy} lists the calculated speedups compared to both the VeloCty version with bounds checks and without bounds checks. The geometric mean of the speedups over the VeloCty version without checks is 1.88. The highest speedup, 3.88 was observed for the pairwise benchmark, whereas the smallest, 0.87 was observed for the fft benchmark. 

In case of the speedups over the VeloCty version with checks enabled, we observed a geometric mean of 2.38. The maximum speedup, 7.54 was observed for the pairwise benchmark and the smallest speedup, 0.95 was observed for the fft benchmark. 

Note that since none of the Python benchmarks contained any array slicing operations or array operations, performance would not differ when the mememory optimisation was used and hence we do not specify those numbers in this subsection. 
\section{Summary}
In summary, the VeloCty code with all optimisations enabled generated by \velocty from \matlab is 7.89 times faster than the Mathwork's \matlab. The generated VeloCty code for Python is 391.04 times faster than the C-Python interpreter.  
