An important contribution of the thesis is the static generation of C++ code from VRIR. Due to differences in the semantics of VRIR and C++, we faced various challenges during code generation. As described in \chapref{chap:Background}, VRIR is a high level strongly typed AST designed to support easy compilation of a wide range of Array based languages. Hence, it supports different indexing schemes such as 0-indexing, 1-indexing and negative indexing as well as different array layout schemes such as row-major and column-major. C++ on the other hand does not have an built in support for arrays, and only supports 0-indexing and a row major layout. Moreover, VRIR also supports multiple returns. On the other hand, we can only return a single value, which can be a scalar, class, struct or a pointer, in C++. This chapter describes how different nodes in VRIR are mapped to C++ constructs including those which C++ does not implicitly support.
\section{Mapping Types}
Data types in VRIR, known as VTypes, can be categorised into 5 types :
\subsection{Scalar Type}
The scalar type is used define the primitive data type.
Different types of Scalar values are Int32, Int64, Float32, Float64 and Bool.
The mapping of VTypes to different C++ types is shown in table \ref{tab:typeMap}.
\begin{table}[h]
\centering
\begin{tabular}{|c|c|c|c|}
\hline
\multicolumn{2}{|c|}{Scalar Type}                                                                 & \multirow{2}{*}{Real / Complex}  & \multirow{2}{*}{C++ types} \\ \cline{1-2}
Name                                         & S-Expression                                      &                              &                            \\ \hline
\multirow{2}{*}{Float32}                     & \multicolumn{1}{c|}{\multirow{2}{*}{( float32 )}} & REAL                         & float                        \\ \cline{3-4} 
                                             & \multicolumn{1}{c|}{}                             & \multicolumn{1}{c|}{COMPLEX} & float complex              \\ \hline
\multirow{2}{*}{Float64}                     & \multicolumn{1}{c|}{\multirow{2}{*}{( float64 )}} & REAL                         & double                       \\ \cline{3-4} 
                                             & \multicolumn{1}{c|}{}                             & \multicolumn{1}{c|}{COMPLEX} & double complex             \\ \hline
\multicolumn{1}{|c|}{\multirow{2}{*}{Int32}} & \multirow{2}{*}{( int32 )}                        & REAL                         & int                      \\ \cline{3-4} 
\multicolumn{1}{|c|}{}                       &                                                   & \multicolumn{1}{c|}{COMPLEX} & Not Supported                          \\ \hline
\multicolumn{1}{|c|}{\multirow{2}{*}{Int64}} & \multirow{2}{*}{( int64 )}                        & REAL                         & long                     \\ \cline{3-4} 
\multicolumn{1}{|c|}{}                       &                                                   & \multicolumn{1}{c|}{COMPLEX} & Not Supported                          \\ \hline
\multicolumn{1}{|c|}{\multirow{2}{*}{Bool}} & \multirow{2}{*}{( bool )}                        & REAL                         & bool                     \\ \cline{3-4} 
\multicolumn{1}{|c|}{}                       &                                                   & \multicolumn{1}{c|}{COMPLEX} & Not Supported                          \\ \hline
\end{tabular}
\caption[VType to C++ type mapping]{VType to C++ type mapping. The tables shows the different C++ will be mapped to from the VTypes.} 
\label{tab:typeMap}
\end{table}
\subsection{Array Types}
\begin{table}[htbp]
\centering
\begin{tabular}{|c|c|c|c|}
\hline
\multicolumn{3}{|c|}{Array Type}                                                                                                                                                                                  & \multirow{2}{*}{VrArray}         \\ \cline{1-3}
Name                                                                       & Real / Complex & S-expression                                                                                                            &                                  \\ \hline
\multirow{2}{*}{\begin{tabular}[c]{@{}c@{}}Float64\\ Array\end{tabular}}   & REAL       & \begin{tabular}[c]{@{}c@{}}( arraytype :ndims :layout \\ ( float64 :ctype complex) )\end{tabular}                       & VrArrayF64                       \\ \cline{2-4} 
                                                                           & COMPLEX    & \multicolumn{1}{l|}{\begin{tabular}[c]{@{}l@{}}( arraytype :ndims :layout \\ ( float64 :ctype complex) )\end{tabular}}  & \multicolumn{1}{c|}{VrArrayCF64} \\ \hline
\multirow{2}{*}{\begin{tabular}[c]{@{}c@{}}Float32 \\ Array\end{tabular}}  & REAL       & \begin{tabular}[c]{@{}c@{}}( arraytype :ndims \\ :layout \\ ( float32  ctype: real ) )\end{tabular}                     & VrArrayF32                       \\ \cline{2-4} 
                                                                           & COMPLEX    & \multicolumn{1}{l|}{\begin{tabular}[c]{@{}l@{}}( arraytype :ndims :layout \\ ( float32,ctype: complex ) )\end{tabular}} & \multicolumn{1}{l|}{VrArrayCF32} \\ \hline
\begin{tabular}[c]{@{}c@{}}Int32 \\ Array\end{tabular}                     & REAL       & \begin{tabular}[c]{@{}c@{}}( arraytype :ndims :layout \\ ( int32 ctype: real ) )\end{tabular}                           & VrArrayI32                       \\ \hline
\begin{tabular}[c]{@{}c@{}}Int64 \\ Array\end{tabular}                     & REAL       & \begin{tabular}[c]{@{}c@{}}( arraytype :ndims :layout \\ ( int32 ctype: real ) )\end{tabular}                           & VrArrayI64                       \\ \hline
\multicolumn{1}{|c|}{\begin{tabular}[c]{@{}l@{}}Bool\\ Array\end{tabular}} & REAL       & \multicolumn{1}{l|}{\begin{tabular}[c]{@{}l@{}}( arraytype :ndims :layout \\ ( int32 ctype: real ) )\end{tabular}}      & \multicolumn{1}{c|}{VrArrayB}    \\ \hline
\end{tabular}
\caption[Array Types]{ArrayType map. The table shows the VrArray types the ArrayTypes in VRIR are mapped to.}
\label{tab:arrayTypeMap}
\end{table}

\begin{table}[htbp]
\centering
\begin{tabular}{|c|c|}
\hline
VrArray Type & Data Field Type \\ \hline
VrArrayF64   & double          \\ \hline
VrArrayF32   & float           \\ \hline
VrArrayCF64  & double complex  \\ \hline
VrArrayCF32  & float complex  \\ \hline
VrArrayI64   & long            \\ \hline
VrArrayI32   & int             \\ \hline
VrArrayB     & bool            \\ \hline
\end{tabular}
\caption[Data field types of different VrArrays]{Data field types of different VrArrays. Table depicting the types of the data field for different VrArray types.}
\label{tab:arrayDataMap}
\end{table}
Unlike array-based languages, C++ arrays do not store additional information such as the number of dimensions or the sizes of each dimensions. This information is useful while performing various operations such as multiplication, addition etc and hence it was necessary for us to store it. One solution was to take store this information separately. However, this approach increases the number of parameters that need to be passed to functions implementing array operations. Moreover, when assigning to an array additional code that needs to be generated to update the dimension sizes and the number of dimensions. Hence, we implemented structs for arrays of all the data types supported by VRIR. We call the structs collectively as VrArrays. The equivalent VrArray types for different array types are shown in table \ref{tab:arrayTypeMap}.
\subsubsection{VrArrays}
VrArrays are represented as C++ structs and encapsulate array data as well as the meta-data. They contain a pointer to the data as well as other necessary information such as the number of dimensions and the size of each dimension. There are different VrArrays for different data types. The different VrArray types and the VRIR types from which they are mapped are given in table \ref{tab:arrayTypeMap}. The structure of the different VrArrays in given below. Each VrArray has a data field which is a pointer to the array data. The type of the data field depends on the type of the VrArray. For example, the type of VrArrayF64, which is used to represent an float64 array is double. 
There are separate VrArray types for complex and real arrays of the same type. All operations on arrays in the language runtime take VrArrays as input. This allows single parameter to be passed for array instead of passing the data, dimensions and number of dimensions separately. The full list of VrArrays and the types of their corresponding data fields is given in table \ref{tab:arrayDataMap}.
\begin{lstlisting}[language=c, label={vrArrayF64Struct}, caption={Structures of VrArrays for real data}]
typedef struct VrArrayF64{
  double *data;
  dim_type* dims;  
  int ndims;
}VrArrayF64;

typedef struct VrArrayF32{
  float *data;
  dim_type* dims;  
  int ndims;
}VrArrayF32;

typedef struct VrArrayI32{
  int *data;
  dim_type* dims;  
  int ndims;
}VrArrayI32;

typedef struct VrArrayI64{
  int *data;
  dim_type* dims;  
  int ndims;
}VrArrayI64;

\end{lstlisting}

\begin{lstlisting}[language=c, label={vrArrayF64Struct}, caption={Structures of VrArrays for complex data}]

typedef struct VrArrayCF32{
  float complex *data;
  dim_type* dims;  
  int ndims;
}VrArrayCF32;

typedef struct VrArrayCF64{
  double complex *data;
  dim_type* dims;  
  int ndims;
}VrArrayCF64;

\end{lstlisting}

\subsection{Void Type}
\begin{table}[htbp]
\centering
\begin{tabular}{|c|c|}
\hline
Void Type & Generated Void \\ \hline
( void)   & void           \\ \hline
\end{tabular}
\caption[voidTypeMapping]{The table describes the generated C++ code for a void type.}
\label{tab:voidTypeMap}
\end{table}
The void type is used in most cases inside a Func Type to convey the absence of either input or output parameters. The void type is mapped to a simple `void' in C++. Table \ref{tab:voidTypeMap} shows the mapping
\subsection{Tuple Type}
Tuple types are used to define data structures which can have data of different types. While generating C++ code, the tuple types are used to generate structs that are in turn used to support data structures containing heteregenous data.
\subsection{Func Type}
Func types are associated with function definitions and function handles. They contain information about the types of the input and out parameters of the function. The function types are used for generating function definition. More information about how function definitions are generated in given in section \ref{sec:functions}.
\section{Modules}
Modules are top-level constructs in VRIR. They contain one or more functions which have to be compiled to C++. A module also has an attribute called indexing which defines the indexing scheme. The indexing scheme can either be 0 or 1 indexing. More details about how the indexing attribute is used can be found in section \ref{subsec:basicindexing}.
\section{Functions} 
\label{sec:functions}
\begin{table}[htbp]
\begin{tabular}{|l|l|}
\hline
\multicolumn{1}{|c|}{Func Type}                                                                                                                                                                                                                                       & \multicolumn{1}{c|}{Generated Function}                                                          \\ \hline
\begin{tabular}[c]{@{}l@{}} (function babai \\
   (functype \\
   (intypes \\
   ( arraytype :layout colmajor :ndims 2(float64 :ctype 0)) \\
	( arraytype :layout colmajor :ndims 2(float64 :ctype 0))) \\
   (outtypes \\
   ( arraytype :layout colmajor :ndims 2(float64 :ctype 0)))) \\
	(arglist \\
   (arg :id0 \\
   )(arg :id1 \\
   )) \\
	(body ... )
\end{tabular} & \begin{tabular}[c]{@{}l@{}}VrArrayPtrF64 \\ babai (VrArrayPtrF64 R,VrArrayPtrF64 y)\end{tabular} \\ \hline
\end{tabular}
\caption[funcTypeMap]{The table shows an example func type and the equivalent function signature that was generated using the func type.}
\label{tab:funcTypeMap}
\end{table}
Functions in VRIR are compiled to separate functions in C++. The function node in VRIR has multiple children all of which are required to generate the C++ code for the function. The list of children node of the function node and their role in the code generation process is as follows :
\begin{itemize}
\item Name : The function name represents the name of the function. A C++ function of the same name is generated.   
\item Arglist : The arglist is a list of integers which are the Ids of the input arguments in the symbol table.
\item Func type : The Func type is used for generating the input argument types and the return type.
\item Body : The body represents the body of the function. It consists of a list of statements. 
\end{itemize}
The table \ref{tab:funcTypeMap} depicts how a function node in VRIR is converted to a C++ function.
\subsection{Return types in VRIR}
\begin{lstlisting}[language=c,caption={Generated structure to handle multiple returns.},label={lst:multReturn}]
//Structure definition
typedef struct struct_adapt_ret { 
   VrArrayPtrF64 ret_data0;
   double ret_data1;
   double ret_data2;
   
   struct_adapt_ret(VrArrayPtrF64 ret_data0,double ret_data1,double ret_data2) :ret_data0(ret_data0),ret_data1(ret_data1),ret_data2(ret_data2)
   {
   }
   
}struct_adapt_ret;

//Function declaration
struct_adapt_ret adapt(double a,double b,double sz_guess,double tol);
\end{lstlisting}
C++ only permits single return types. On the other hand, VRIR supports multiple return types. In order to bridge this difference in semantics, we generate a struct definition whose fields are of the same types as the return types. A parameterized constructor is also provided to assign the different variables that need to be returned to the member fields of the struct. The structure definition and the function definition that returns the structure is shown in listing \ref{lst:multReturn}. The struct name is generated using the name of the function. The format of a struct for multiple returns is, struct\_<function name>\_ret. This allows the calling function to determine the name of the struct while declaring a variable. 
\section{Statements}
VRIR supports various statements such as assignments, for-loops, while-loops etc. Most of the statements are directly supported in C++. The assignment, for and return statements have special cases which need to be supported. VRIR also supports the parallel for statement. This statement is compiled to an equivalent for loop with OpenMP pragmas in C++.
\subsection{Assignment Statement}
While generating C++ code for the assignment statement, we had to take into account different variations of the statement as well generate additional code. Different variations include statements with an array slice operation on the left hand side, statements containing function calls on the right hand side which have multiple returns etc. 
\subsubsection{Simple Assignment Statements}
Simple assignment statements are used when the left hand side is a name expression or an index expression without the array slice operator. The number of expressions on the left hand side can not be more than one. An example of a simple assignment statement is given in table \ref{tab:simpleAssignment}.
	\begin{table}[htbp]
	\begin{tabular}{|l|l|}
					\hline
							VRIR & Generated C++ code\\
							\hline
{
\begin{lstlisting}[frame=none, language=lisp, label={lst:SimpleAssignment},numbers=none]
(assignstmt
 (lhs
	(name :id 5
	 (float64 :ctype 0)
	)
 )
 (rhs
	(index :arrayid 0 :copyslice %0
	 (arraytype :layout colmajor :ndims 2
				(float64 :ctype 0)
	 )
	 (indices
				(index :boundscheck %1 :negative %0
					 (name :id 4
							(int64 :ctype 0)
					 )
				)
	 )
	)
 )
)
\end{lstlisting}
} & 
{
\begin{lstlisting}[frame=none, language=c, label={lst:SimpleAssignment},numbers=none]
temp = VR_GET_DATA_F64(A)[(i - 1)];
\end{lstlisting}
} \\
\hline
\end{tabular}
\caption[Simple Assignment Statement]{ The table shows an example of the simple assignment statement in VRIR and the equivalent C++ code that is generated from it.}
\label{tab:simpleAssignment}
\end{table}
\subsubsection{Assignment Statements with Array Slice set}
\begin{table}[htbp]
\begin{tabular}{|c|c|}
\hline
VRIR & C++ backend \\
\hline
{
\begin{lstlisting}[language=lisp, frame=none, numbers=none]
(assignstmt
	(lhs
		(index :arrayid 12 :copyslice %0 
			( arraytype :layout colmajor :ndims 2
			 	(float64 :ctype 0))
		  (indices
				(index :boundscheck %1 :negative %0
			 		(range :exclude %0
			  		(start 
			   			(plus
								(int64 :ctype 0)
								(lhs
				 					(name :id 13
				  					(int64 :ctype 0)
									)
								)
								(rhs
				 					(realconst :ival 1
				  					(int64 :ctype 0)))))
			  		(stop 
			   			(name :id 8
								(float64 :ctype 0)
			   			)
			  		)
			 	)
			)
		 )
	 )
	)
	(rhs
		<RHS Expression>)
	)
\end{lstlisting}
} & 
{
\begin{lstlisting}[language=c,frame=none, numbers=none]
rrk.setArraySliceSpec
	(<RHS Expression>, 
	VrIndex((k + 1),n,1));
		\end{lstlisting}
} \\
\hline
\end{tabular}
\caption[Assignment with array slice set]{Table shows VRIR with array slicing on the LHS and the equivalent C++ code that is generated.}
\label{tab:sliceAssign}
\end{table}
In assignment statements which fall under this category, the left hand side expression is an index expression with atleast one slice index. The right hand side can be any expression. The array slice set operation allows a region of the array to be assigned values. Since C++ does not support this, we have provide a function in the runtime library which implements this. During code generation, the assignment statement is compiled to the function callimplementing array slice set. The parameters to this call are the array variable of index expression on the left hand side, the right hand side expression and the set of indices which define the region of the array to which the values have to be assigned to. The indices are converted to VrIndex structs. More information to VrIndex can be found sub-section \ref{subsubsec:vrindex}. Table \ref{tab:sliceAssign} shows a VRIR representation with a slice operation on the left hand side and the equivalent C++ code that is generated.
\subsubsection{Assignment statements that can be optimised  for redundant memory allocations}
\begin{table}[htbp]
\begin{tabular}{|c|c|}
\hline 
VRIR & C++ backend \\
\hline 
{
\begin{lstlisting}[language=lisp, frame=none, numbers=none]
(assignstmt
	(lhs
		(name :id 5
   			( arraytype :layout colmajor :ndims 2
				(float64 :ctype 0)
			)
		)
	)
	(rhs
		(libcall :libfunc mmult
			( arraytype :layout colmajor :ndims 2
				(float64 :ctype 0))
			(args
   				(name :id 5
   					( arraytype :layout colmajor :ndims 2
						(float64 :ctype 0)
					)
				)
				(name :id 5
					( arraytype :layout colmajor :ndims 2
						(float64 :ctype 0)
					)
				)
			)
		)
	)
)
\end{lstlisting}
} & 
{
\begin{lstlisting}[language=c,frame=none, numbers=none]
BlasDouble::mmult
	(CblasColMajor,CblasNoTrans
	,CblasNoTrans
	,B,B, &B);
\end{lstlisting}
} \\
\hline
\end{tabular}
\caption[Assignment with Memory optimisation]{Table shows VRIR with array operations on the LHS and the equivalent C++ code that is generated and optimised.}
\label{tab:memAssignment}
\end{table}
One of the contributions of the thesis was an optimisation where redundant memory allocations during operations on arrays are removed. This optimisation is implemented by passing the array to which the result is assigned to, as a parameter to the function implementing the array operation. This array is the left hand side expression of the assignment statement whereas the right hand side expression is the function call. More information on the optimisation can be found in section \ref{sec:memoptimise}. Table \ref{tab:memAssignment} gives an example of a VRIR representation which can potentially be optimised and the generated C++ code. 

\subsubsection{Assignment Statements with multiple LHS expressions}
\begin{table}[htbp]
\begin{tabular}{|c|c|}
\hline 
VRIR & C++ backend \\
\hline 
{
\begin{lstlisting}[language=lisp, frame=none, numbers=none]
(assignstmt
  (lhs
    (tuple
      (tupletype
        (float64 :ctype 0)
        ( arraytype :layout colmajor:ndims 2
          (float64 :ctype 0)
        )
        ( arraytype :layout colmajor:ndims 2
          (float64 :ctype 0))
        ( arraytype :layout colmajor:ndims 2
          (float64 :ctype 0)
        )
      )
      (elems
        (name :id 3
          (float64 :ctype 0)
        )
        (name :id 8
          ( arraytype :layout colmajor:ndims 2
            (float64 :ctype 0)
          )
        )
        (name :id 4
          ( arraytype :layout colmajor:ndims 2
            (float64 :ctype 0)))  
        (name :id 9
          ( arraytype :layout colmajor:ndims 2
            (float64 :ctype 0)
          )
        )
      )
    )
  )
  (rhs
      <RHS Expression>
  )
)
\end{lstlisting}
} & 
{
\begin{lstlisting}[language=c,frame=none, numbers=none]
struct_spqr_ret var_spqr1 = <rhsExpr> 
nr = var_spqr1.ret_data0;
S = var_spqr1.ret_data1;
rx = var_spqr1.ret_data2;
rn = var_spqr1.ret_data3;
\end{lstlisting}
} \\
\hline
\end{tabular}
\caption[Assignment with multiple LHS expressions]{Table shows VRIR with multiple expressions on the LHS and the equivalent C++ code that is generated.}
\label{tab:multAssignment}
\end{table}
Assignment statements can have multiple expressions on the LHS when the RHS expression is a function call with multiple returns. As mentioned in section \ref{sec:functions}, functions with multiple returns are handled by returning a struct containing the return values. In the assignment statement the expression on the LHS are replaced by a struct variable and additional code is generated to assign the values in the struct to the LHS expressions. Table \ref{tab:multAssignment} shows the C++ code that is generated from VRIR.

\subsection{For Statement}
\begin{table}[htbp]
\begin{tabular}{|c|c|}
\hline 
VRIR & C++ backend \\
\hline 
{
\begin{lstlisting}[language=lisp, frame=none, numbers=none]
(forstmt
	(itervars
		(sym :id 7)
	)
	(loopdomain
		( domain 
			( domaintype :ndims 1 
				(int64 :ctype 0)
			)
			(range :exclude %0
				(start
					(realconst :ival 1
						(int64 :ctype 0)
					)
				)
				(stop
					(name :id 3
						(float64 :ctype 0)
					)
				)
			)
		)
	)
	(body
		<Loop Body>
	)
)

\end{lstlisting}
} & 
{
\begin{lstlisting}[language=c,frame=none, numbers=none]
for(h=1;h<= k;h=h+static_cast<long>(1)) {
	<Loop Body>
}
\end{lstlisting}
} \\
\hline
\end{tabular}
\caption[For Statement]{The table shows a for statement node in VRIR and its equivalent C++ code}
\label{tab:forStmt}
\end{table}
The For statement node in VRIR is compiled to a for loop is C++. The domain node of the for statement is used to determine the ranges over which the for loop iterates. If there are multiple ranges in the domain node, the for statement node is compiled into multiple nested loops. The names of the loop variables is determined by fetching their IDs from the itervar node and using their IDs to look up their names in the symbol table. An example of the generated in given in table \ref{tab:forStmt}. The table 
\begin{table}[htbp]
\begin{tabular}{|l|l|}
\hline

For loop excluding stop value & 
{
\begin{lstlisting}[language=c,frame=none, numbers=none]
for(h=1; h< k; h=h+static_cast<long>(1)) {
	<Loop Body>
}
\end{lstlisting}
}
 \\
\hline 

For loop including stop value & 
{
\begin{lstlisting}[language=c,frame=none, numbers=none]
for(h=1; h<= k; h=h+static_cast<long>(1)) {
	<Loop Body>
}
\end{lstlisting}
} \\
\hline
\end{tabular}
\caption[Use of exclude flag in For statement]{Table shows a C++ for loop with the exclude flag set to 0 and 1.}
\label{tab:excludeFor}
\end{table}
\subsubsection{Determining inclusion of the Stop expression}
The loop domain node of the for statement gives the start, stop and step expressions for each range. These expressions are used to generate the initialisation, condition and increment statements of the C++ for loop. We have to determine whether the range is  inclusive of the stop value.  This is done using the exclude flag of the range expression. If the flag is set to `\%1', the value is excluded whereas it is included if the flag is set to `\%0'. In case of an excluded stop value, the `<' or the `>' operator is used in the condition statement and the `<=' or the `>=' operator is used in case of an included stop value. Table \ref{tab:excludeFor} gives an example the generated for loops with and without including the stop value.
\subsubsection{Determining loop direction}
\begin{table}[htbp]
\centering
\begin{tabular}{|c|c|c|}
\hline
Start and Stop values & Step Value & Loop Direction \\ \hline
\multirow{2}{*}{Stop  \textgreater  Start} & Negative & Empty Loop \\ \cline{2-3} 
 & Positive & Increment \\ \hline
\multirow{2}{*}{Stop \textless Start} & Negative & Decrement \\ \cline{2-3} 
 & Positive & Empty Loop \\ \hline
\end{tabular}
\caption[Loop Direction]{Table shows the direction of a for loop for various start, stop and step values}
\label{tab:loopDirection}
\end{table}
While generating code for the for statement, the direction of the loop can be determined by the start, stop and step values. Table \ref{tab:loopDirection} shows the directions of a for loop for different values of start,stop and step. The loop direction can only be determined if the value of the step value is known during compilation. In order to determine the loop direction we check whether the step expression is  a constant expression or a negate expression with a constant expression as its child.
\subsubsection{ Generating the loop vector}
If the direction of the loop cannot be determined at compile time, we add declare a vector in the generate code. All possible of the loop variable will be inserted into the vector at run time. The generated loop iterates over the vector and the loop variable is assigned consecutive values of the vector inside the loop body. 
% TODO:add example
\subsection{Return Statement}
\begin{table}[htbp]
\centering
\begin{tabular}{|l|l|}
\hline

VRIR &  Generated C++ \\
\hline
{
\begin{lstlisting}[language=c,frame=none, numbers=none]
(returnstmt
	(exprs
		(name :id 7
			(float64 :ctype 0)
		)
	)
)
\end{lstlisting}
}
&
{
\begin{lstlisting}[language=c,frame=none, numbers=none]
return cap;
\end{lstlisting}
} \\
\hline
\end{tabular}
\caption[Simple return statement]{The table shows a return statement with a single return value and its equivalent C++}
\label{tab:simpleReturn}
\end{table}
\begin{table}[htbp]
\centering
\begin{tabular}{|l|l|}
\hline

VRIR &  Generated C++ \\
\hline
{
\begin{lstlisting}[language=c,frame=none, numbers=none]
(returnstmt
  (exprs
    (name :id 3
      (float64 :ctype 0)
    )
    (name :id 4
      ( arraytype :layout colmajor :ndims 2
        (float64 :ctype 0)
      )
    )
    (name :id 5
      ( arraytype :layout colmajor :ndims 2
        (float64 :ctype 0)
      )
    )
    (name :id 6
      ( arraytype :layout colmajor :ndims 2
        (float64 :ctype 0)
      )
    )
  )
)
\end{lstlisting}
}
&
{
\begin{lstlisting}[language=c,frame=none, numbers=none]
return struct_spqr_ret
          (ncols,R,colx,norms);
\end{lstlisting}
} \\
\hline
\end{tabular}
\caption[Simple return statement]{The table shows a return statement with a single return value and its equivalent C++}
\label{tab:multiReturn}
\end{table}
For return statements with single return variable, a simple return statement is generated. The expressions inside the return statement are replaced with their Ids inside the symbol table. If the expressions are not name expressions, they are assigned to a temporary variables which are then returned. Table \ref{tab:simpleReturn} gives an example of a simple return statement.
Since C++ does not support return statements with multiple variables, we return a struct instead. The values of the variables are passed as parameters to the struct's constructor. Table \ref{tab:multiReturn} gives an example of the return statement with multiple returns values.
\subsection{If Statement}
\begin{table}[htbp]
\centering
\begin{tabular}{|l|l|}
\hline

VRIR &  Generated C++ \\
\hline
{
\begin{lstlisting}[language=lisp,frame=none, numbers=none]
(ifstmt
	(test
		<Test Condition>
	)
	(if
		<If Block>
	)	
	( else 
		<Else block>
	)
)
\end{lstlisting}
}
&
{
\begin{lstlisting}[language=c,frame=none, numbers=none]
 if(Test condition) { 
	<If Block>

 } else {

	<Else Block>
 }
\end{lstlisting}
} \\
\hline
\end{tabular}
\caption[If Statement Example]{The table shows an example of a if statement in VRIR and its equivalent C++ code.}
\label{tab:ifStmt}
\end{table}
The if statement is compiled to a condition statement, an if block and an else block if it exists.  Table \ref{tab:ifStmt} gives an example of the if statement.
\subsection{Break Statement}
\begin{table}[htbp]
\centering
\begin{tabular}{|l|l|}
\hline

VRIR &  Generated C++ \\
\hline
{
\begin{lstlisting}[language=lisp,frame=none, numbers=none]
(break)
\end{lstlisting}
}
&
{
\begin{lstlisting}[language=c,frame=none, numbers=none]
break;
\end{lstlisting}
} \\
\hline
\end{tabular}
\caption[Break statement example]{The table shows an example of a break statement in VRIR and its equivalent C++ break statement}
\label{tab:breakStmt}
\end{table}
The break statement of VRIR is compiled to the break statement in C++. Table \ref{tab:breakStmt} gives an example of the continue statement.
\subsection{Continue Statement}
\begin{table}[htbp]
\centering
\begin{tabular}{|l|l|}
\hline

VRIR &  Generated C++ \\
\hline
{
\begin{lstlisting}[language=lisp,frame=none, numbers=none]
(continue)
\end{lstlisting}
}
&
{
\begin{lstlisting}[language=c,frame=none, numbers=none]
continue;
\end{lstlisting}
} \\
\hline
\end{tabular}
\caption[While statement example]{The table shows an example of a while statement in VRIR and its equivalent C++ while statement}
\label{tab:continueStmt}
\end{table}
The continue statement of VRIR is compiled to the continue statement in C++. Table \ref{tab:continueStmt} gives an example of the continue statement.
\subsection{While Statement}
\begin{table}[htbp]
\centering
\begin{tabular}{|l|l|}
\hline

VRIR &  Generated C++ \\
\hline
{
\begin{lstlisting}[language=lisp,frame=none, numbers=none]
(while 
	(test <While Condition>)
	(body 
		<Loop Body>
	)
)
\end{lstlisting}
}
&
{
\begin{lstlisting}[language=c,frame=none, numbers=none]
while(condition) {
	<Loop Body>
}
\end{lstlisting}
} \\
\hline
\end{tabular}
\caption[While statement example]{The table shows an example of a while statement in VRIR and its equivalent C++ while loop}
\label{tab:continueStmt}
\end{table}
The while statement is compiled to a while loop in C++. The test node of the statement is used to generate the while condition. Statements inside the body node are compiled to the statements inside the loop body.
\subsection{Parallel For Statement}
\begin{table}[htbp]
\centering
\begin{tabular}{|l|l|}
\hline

VRIR &  Generated C++ \\
\hline
{
\begin{lstlisting}[language=lisp,frame=none, numbers=none]
( pfor
	(itervars 
		(sym :id 6 
		)
	)
	(loopdomain 
	  ( domain ( domaintype :ndims 1 (int64 :ctype 0))
		(range :exclude %0 
   			(start  
   				(realconst :ival 1
					(int64 :ctype 0)
				)
			)
			(stop  
   				(name :id 4 
					(float64 :ctype 0)
				)
			)
		)
	   )
	)
	(shared  3 4 5 )
)
\end{lstlisting}
}
&
{
\begin{lstlisting}[language=c,frame=none, numbers=none]
#pragma omp parallel for  \
	shared(A,B,c)
 for( i = 0; 
		i < static_cast<long>(m);
		i++) {
	<Loop Body>
 }

\end{lstlisting}
} \\
\hline
\end{tabular}
\caption[Parallel For example]{The table shows an example of a parallel for statement in VRIR and its equivalent C++ for loop with OpenMP}
\label{tab:pForStmt}
\end{table}
A parallel for loop is compiled to a for loop  in C++ with an openMP pragma inserted before the loop. The shared variables node of the parallel for statement contains IDs of the variables that are shared and are added to the shared option of OpenMP. Table \ref{tab:pForStmt} gives an example of the parallel for statement.
\subsection{Statement List}
A statement list is used to define multiple statements and is often a child node of the If, For and While statements as well as the Function node.
\section{Expressions}
Most expressions VRIR can be compiled to equivalent expressions in C++. Expressions such as index expressions have special cases which need to be considered. The following subsections explain the compilation of the VRIR different expressions.
\subsection{Operators}
\label{subsec:operators}
			\begin{table}[htbp]
					\centering
					\begin{tabular}{|c|c|}
					\hline
					VRIR operators & C++ Operators \\ \hline
					plus           & +             \\ \hline
					minus          & -             \\ \hline
					mult           & *             \\ \hline
					div            & /             \\ \hline
					and            & \&\&           \\ \hline
					or             & ||            \\ \hline
					lt             & \textless     \\ \hline
					leq            & \textless=    \\ \hline
					gt             & \textgreater  \\ \hline
					geq            & \textgreater= \\ \hline
					eq             & ==            \\ \hline
					neq            & !=            \\ \hline
					\end{tabular}
					\caption[opMap]{VRIR operators to C++ operators Mapping. The table shows the C++ operators to which the VRIR operators are mapped.}
					\label{tab:opMap}
					\end{table}
					\begin{table}[htbp]
					\centering
					\begin{tabular}{|c|c|c|c|}
					\hline
					VRIR Lib Call                               & Operand 1 & Operand 2 & C++ function \\ \hline
					\multirow{2}{*}{Matrix Multiplication}      & Array     & Array     & mmult        \\ \cline{2-4} 
					& Array     & Scalar    & scal\_mult   \\ \hline
					\multirow{2}{*}{Elementwise Multiplication} & Array     & Array     & vec\_mult    \\ \cline{2-4} 
					& Array     & Scalar    & scal\_mult   \\ \hline
					\multirow{2}{*}{Matrix Left Division}       & Array     & Array     & mat\_ldiv    \\ \cline{2-4} 
					& Array     & Scalar    & scal\_div    \\ \hline
					\multirow{2}{*}{Matrix Right Division}      & Array     & Array     & mat\_rdiv    \\ \cline{2-4} 
					& Array     & Scalar    & scal\_div    \\ \hline
					\multirow{2}{*}{Elementwise Division}       & Array     & Array     & elem\_div    \\ \cline{2-4} 
					& Array     & Scalar    & scal\_div    \\ \hline
					\multirow{2}{*}{Array Addition}             & Array     & Array     & vec\_add     \\ \cline{2-4} 
					& Array     & Scalar    & scal\_add    \\ \hline
					\multirow{2}{*}{Array Subtraction}          & Array     & Array     & vec\_sub     \\ \cline{2-4} 
					& Array     & Scalar    & scal\_minus  \\ \hline
					Array Copy                                  & Array     & Array     & vec\_copy    \\ \hline
					Matrix Transpose                            & Array     & -         & transpose    \\ \hline
					\end{tabular}
					\caption[List of operations on Arrays]{The table shows the different C++ functions array operators are mapped to. }
					\label{tab:arrayOpMap}
					\end{table}
Many binary and unary expressions in VRIR can be classified as arithemetic operators.These include binary expressions such as  plus, minus, mult, div and the negate expression. These expressions  only support scalar operands. Hence generating C++ code these operators is straightforward. They are mapped to the operators directly supported by C++. Thus plus is mapped to the `+' operator in C++, minus is mapped to `-'. The complete list is given in table \ref{tab:opMap}. \\
Operations on arrays, on the other hand, are mapped to the LibCall expression in VRIR. Since C++ does not have internal operators for arrays we implemented function to support these operations on arrays. These functions are housed inside the language-specific runtime library. Where ever possible these functions made calls to BLAS functions for enchanced performance. In case of the \matlab runtime, we use the Intel Math Kernel Library\cite{mkl} or MKL implementation of BLAS and in case of Python, we use the openBLAS\cite{openblas} implementation.
\subsection{Name Expressions}
\begin{table}[htbp]
\centering
\begin{tabular}{|l|l|}
\hline

VRIR &  Generated C++ \\
\hline
{
\begin{lstlisting}[language=lisp,frame=none, numbers=none]
(name :id 2
   (int64 :ctype 0)
)
\end{lstlisting}
}
&
{
\begin{lstlisting}[language=c,frame=none, numbers=none]
A
\end{lstlisting}
} \\
\hline
\end{tabular}
\caption[Name Expressions example]{The table shows an example of a name expression in VRIR and its equivalent C++ symbol}
\label{tab:nameExpr}
\end{table}
The name expressions in VRIR denote variables. The `Id' attribute of the name expressions is used to fetch the symbol string from the symbol table. All name expressions that are not passed as parameters to the function are declared at the start of the function body. Table \ref{tab:nameExpr} gives an example of name expressions.
\subsection{Function call expressions}
Function call expressions in VRIR are used to describe calls to functions that are not defined by  the library call expression or the alloc expression. A function call expression may have zero or more arguments. Arguments can be passed by reference or a copy of the arguments could be passed to the function. We define certain functions as builtins. These are functions that we support through the runtime library. Arguments to builtins are always passed by reference.
\subsection{Domain Expression}
Domain expressions are used inside for statements to define the ranges of the for loops. A domain expressions can have one or more ranges. All domain expressions are of the domain type. Table \ref{tab:forStmt} gives an example of how domain expressions inside a for statement are used to generate a for loop in C++.
\subsection{Constant Expressions}
\begin{table}[htbp]
\centering
\begin{tabular}{|l|l|l|}
\hline

AttributeType & VRIR &  Generated C++ \\
\hline
dval &
{
\begin{lstlisting}[language=lisp,frame=none, numbers=none]
(realconst :dval 2.3e-12(float64 :ctype 0))
\end{lstlisting}
}
&
{
\begin{lstlisting}[language=c,frame=none, numbers=none]
2.3e-12
\end{lstlisting}
} \\
\hline
dval &
{
\begin{lstlisting}[language=lisp,frame=none, numbers=none]
(realconst :dval 2(float64 :ctype 0))
\end{lstlisting}
}
&
{
\begin{lstlisting}[language=c,frame=none, numbers=none]
2.0f
\end{lstlisting}
} \\
\hline
ival &
{
\begin{lstlisting}[language=lisp,frame=none, numbers=none]
(realconst :ival 2(int64 :ctype 0))
\end{lstlisting}
}
&
{
\begin{lstlisting}[language=c,frame=none, numbers=none]
2
\end{lstlisting}
} \\
\hline
\end{tabular}
\caption[Constant Expression example]{The table shows an example of a constant expression in VRIR and its equivalent C++ constant}
\label{tab:constExpr}
\end{table}
Constant Expressions hold constant values in VRIR. They are compiled to constants inside C++. The type of a constant expressions is defined by the vtype node. A real constant can either have an `ival' or a `dval' attribute which defines an integer value or a floating point value respectively. Table \ref{tab:constExpr} gives an example of constant expressions.
\subsection{Alloc Expression}
\begin{table}[htbp]
\centering
\begin{tabular}{|l|l|}
\hline

VRIR &  Generated C++ \\
\hline
{
\begin{lstlisting}[language=lisp,frame=none, numbers=none]
(alloc :func zeros
	( arraytype :layout colmajor :ndims 2
		(float64 :ctype 0)
	)
	(args
   		(name :id 2
   			(float64 :ctype 0)
		)
		(name :id 4
   			(float64 :ctype 0)
		)
	)
)
\end{lstlisting}
}
&
{
\begin{lstlisting}[language=c,frame=none, numbers=none]
zeros(2,m,k);
\end{lstlisting}
} \\
\hline
\end{tabular}
\caption[Alloc Expression example]{The table shows an example of an alloc expression in VRIR and its equivalent C++ symbol}
\label{tab:allocExpr}
\end{table}
Alloc expressions are used to define functions which allocate memory and initialise it. The expression defines three types of functions zeros, ones and empty each of which are compiled to function calls in the run time library. Table \ref{tab:allocExpr} gives an example of an alloc expression for the zeros function. The generated C++ has an additional parameter to define the number of input parameters. This is because the zeros function call in the runtime library variable arguments.
\subsection{Dim Expression}
Dim Expressions are used to fetch the size of the specific argument of an array. Dim Expressions are compiled to a call to the size function in the runtime library.
\subsection{Tuple Expression}
Tuple expressions are used as for containers for heterogenous data in VRIR. Return values of function calls with multiple returns are assigned to a tuple expressions. The Tuple expressions are also used for \matlab's cell arrays and Python's tuples.
\subsection{Cast Expressions}
Cast Expressions are used to cast an expressions of a certain type to a different type. We assume that the cast is valid and do not add any code to check its validity. Cast Expressions are compiled to a static\_cast in C++.
\section{Index Expressions}
Index expressions in VRIR used to define indexing on arrays. Index expressions have one or more indices. The number of indices is not dependent on the number of dimensions of the array. We classify indexing on arrays into two types, basic indexing and advanced indexing. Flags such as boundscheck and negative define whether boundscheck code needs to be generated for the expressions and whether the index expression supports negative indexing respectively.
\subsection{Basic Indexing}
\label{subsec:basicindexing}
\begin{table}[htbp]
\centering
\begin{tabular}{|l|l|}
\hline

VRIR &  Generated C++ \\
\hline
{
\begin{lstlisting}[language=lisp,frame=none, numbers=none]
(index :arrayid 5 :copyslice %0
	(float64 :ctype 0)
	(indices 
		(index :boundscheck %1 :negative %0 
			(name :id 8 
				(int64 :ctype 0)
			)
		)
		(index :boundscheck %1 :negative %0 
   		(name :id 6 
   			(int64 :ctype 0)
			)
		)
	)
)
\end{lstlisting}
}
&
{
\begin{lstlisting}[language=c,frame=none, numbers=none]
vr_temp9 = VR_GET_DATA_F64(c)[(i - 1) + 
						VR_GET_DIMS_F64(c)[0]*((j - 1))];
\end{lstlisting}
} \\
\hline
\end{tabular}
\caption[Basic array indexing example]{The table shows an example of an index expression in VRIR  with basic indexing and its equivalent C++ symbol}
\label{tab:basicIndex}
\end{table}
Indexing is defined as basic if all the indices are scalars. The indices can also have negative values. The generated code look similar to an array index in C++. However, since VrArray contains a single dimensional pointer to the array data, we have to reduce multiple index values to a single index value during code generation.
\subsubsection{ Generating a single index value from multiple indices}
Generating a single index value is dependent on the array layout. We support both row and column major array layouts and hence support generating single index value generation for both. In case of a row major layout, the last value is contiguous and hence single index value is given by,
\begin{equation}
n_d + N_d \cdot (n_{d-1} + N_{d-1} \cdot (n_{d-2} + N_{d-2} \cdot (\cdots + N_2 n_1)\cdots)))
= \sum_{k=1}^d \left( \prod_{\ell=k+1}^d N_\ell \right) n_k \\
\end{equation} 
 where, $n_i$ is the $i^{th}$ index and  $N_i$ is the $i^{th}$ dimension of the array. \\
And for a column major  layout, the first value is contiguous and hence the single index value is given by,

\begin{equation}
n_1 + N_1 \cdot (n_2 + N_2 \cdot (n_3 + N_3 \cdot (\cdots + N_{d-1} n_d)\cdots)))
= \sum_{k=1}^d \left( \prod_{\ell=1}^{k-1} N_\ell \right) n_k
\end{equation} 
 where, $n_i$ is the $ i^{th}$ index and  $N_i$ is the $i^{th}$ dimension of the array. \\
Table \ref{tab:basicIndex} gives an example of an index expression and its equivalent generated C++ code. The array layout is column major in the case of the example
\subsubsection{Negative Indexing}
Languages such as Python support negative indices. The index refers to an offset from the end of the array dimension. Since C++ does not support negative indexing, replace the indexing scheme mentioned in subsection \ref{subsec:basicindexing} with a call to the function `getIndexVal'. Since it is difficult to determine at compile time if all the indices are non-negative, we make a pessimistic assumption that atleast of the indices will be negative and generate a function call if the negative flag in the index expression is set to 1.
% add example.
\subsection{Advanced Indexing}
We define cases where the array indices are non-scalar as advanced indexing. The indices can either be arrays or ranges. The index expression is compiled to a function call which returns an appropriate value for the given input indices. The function takes as input, arguments of type VrIndex, a struct defined in the runtime library.
\subsubsection{VrIndex}
\label{subsubsec:vrindex}
\begin{lstlisting}[language=c,caption={VrIndex Structure},label={lst:vrIndexStruct}]
struct VrIndex{ 
	bool m_isRange; 
	bool m_isArray; 
	VrArrayF64 arr;      
	union Val{ 
		dim_type const_val; 
		dim_type range_val[3]; 
	}m_val; 
	VrIndex(dim_type const_val);
	VrIndex(dim_type start,dim_type stop,dim_type step);
	VrIndex(VrArrayF64 A);
	VrIndex();
};
\end{lstlisting}
The VrIndex struct is shown in listing \ref{lst:vrIndexStruct}. The structure contains two boolean flags m\_isRange and m\_isArray to differentiate which are used to determine whether the index is a range or an array respectively. If both flags are set to false, the index is a constant value. The constant value is stored in the variable const\_val. The range is stored as an array of size 3. The elements of the array are the start, stop and step values, in order. The array value is store in the variable arr.
\subsubsection{Array Slicing}
\section{Symbol Table}
\section{Run time library}
