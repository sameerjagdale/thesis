An important contribution of the thesis is the static generation of C++ code from VRIR. Due to differences in the semantics of VRIR and C++, we faced various challenges during code generation. As described in \chapref{chap:Background}, VRIR is a high level strongly typed AST designed to support easy compilation of a wide range of Array based languages. Hence, it supports different indexing schemes such as 0-indexing, 1-indexing and negative indexing as well as different array layout schemes such as row-major and column-major. C++ on the other hand does not have an in-built support for arrays, and only supports 0-indexing and a row major layout. Moreover, VRIR also supports multiple returns. On the other hand, we can only return a single value, which can be a scalar, class, struct or a pointer, in C++. This chapter describes how different nodes in VRIR are mapped to C++ constructs including those which C++ does not implicitly support.
\section{Mapping types}
\subsection{VRIR types}
Data types in VRIR, known as VTypes, can be categorised into 5 types :
\subsection{Scalar type}
The scalar type is used define the primitive data type.
Different types of Scalar values are Int32, Int64, Float32, Float64 and Bool.
The mapping of VTypes to different C++ types is shown in table \ref{tab:typeMap}.
\begin{table}[h]
\centering
\begin{tabular}{|c|c|c|c|}
\hline
\multicolumn{2}{|c|}{ScalarType}                                                                 & \multirow{2}{*}{Complexity}  & \multirow{2}{*}{C++ types} \\ \cline{1-2}
Name                                         & S-Expression                                      &                              &                            \\ \hline
\multirow{2}{*}{Float32}                     & \multicolumn{1}{c|}{\multirow{2}{*}{( float32 )}} & REAL                         & float                        \\ \cline{3-4} 
                                             & \multicolumn{1}{c|}{}                             & \multicolumn{1}{c|}{COMPLEX} & float complex              \\ \hline
\multirow{2}{*}{Float64}                     & \multicolumn{1}{c|}{\multirow{2}{*}{( float64 )}} & REAL                         & double                       \\ \cline{3-4} 
                                             & \multicolumn{1}{c|}{}                             & \multicolumn{1}{c|}{COMPLEX} & double complex             \\ \hline
\multicolumn{1}{|c|}{\multirow{2}{*}{Int32}} & \multirow{2}{*}{( int32 )}                        & REAL                         & int                      \\ \cline{3-4} 
\multicolumn{1}{|c|}{}                       &                                                   & \multicolumn{1}{c|}{COMPLEX} & -                          \\ \hline
\multicolumn{1}{|c|}{\multirow{2}{*}{Int64}} & \multirow{2}{*}{( int64 )}                        & REAL                         & long                     \\ \cline{3-4} 
\multicolumn{1}{|c|}{}                       &                                                   & \multicolumn{1}{c|}{COMPLEX} & -                          \\ \hline
\end{tabular}
\caption[VType to C++ type mapping]{VType to C++ type mapping. The tables shows the different C++ will be mapped to from the VTypes.} 
\label{tab:typeMap}
\end{table}
\subsection{Array Types}
C++ does not implicitly define types for arrays. Hence, we implemented structs for arrays of all the data types supported by VRIR. We call the structs collectively as VrArrays. There are separate VrArrays for and real and complex arrays. The different VrArray types for real array are shown in \ref{tab:arrayTypeMap}
\begin{table}[h]
\centering
\begin{tabular}{|c|c|c|c|}
\hline
\multicolumn{3}{|c|}{Array Type}                                                                                                                                                                                  & \multirow{2}{*}{VrArray}         \\ \cline{1-3}
Name                                                                       & Complexity & S-expression                                                                                                            &                                  \\ \hline
\multirow{2}{*}{\begin{tabular}[c]{@{}c@{}}Float64\\ Array\end{tabular}}   & REAL       & \begin{tabular}[c]{@{}c@{}}( arraytype :ndims :layout \\ ( float64 :ctype complex) )\end{tabular}                       & VrArrayF64                       \\ \cline{2-4} 
                                                                           & COMPLEX    & \multicolumn{1}{l|}{\begin{tabular}[c]{@{}l@{}}( arraytype :ndims :layout \\ ( float64 :ctype complex) )\end{tabular}}  & \multicolumn{1}{c|}{VrArrayCF64} \\ \hline
\multirow{2}{*}{\begin{tabular}[c]{@{}c@{}}Float32 \\ Array\end{tabular}}  & REAL       & \begin{tabular}[c]{@{}c@{}}( arraytype :ndims \\ :layout \\ ( float32  ctype: real ) )\end{tabular}                     & VrArrayF32                       \\ \cline{2-4} 
                                                                           & COMPLEX    & \multicolumn{1}{l|}{\begin{tabular}[c]{@{}l@{}}( arraytype :ndims :layout \\ ( float32,ctype: complex ) )\end{tabular}} & \multicolumn{1}{l|}{VrArrayCF32} \\ \hline
\begin{tabular}[c]{@{}c@{}}Int32 \\ Array\end{tabular}                     & REAL       & \begin{tabular}[c]{@{}c@{}}( arraytype :ndims :layout \\ ( int32 ctype: real ) )\end{tabular}                           & VrArrayI32                       \\ \hline
\begin{tabular}[c]{@{}c@{}}Int64 \\ Array\end{tabular}                     & REAL       & \begin{tabular}[c]{@{}c@{}}( arraytype :ndims :layout \\ ( int32 ctype: real ) )\end{tabular}                           & VrArrayI64                       \\ \hline
\multicolumn{1}{|c|}{\begin{tabular}[c]{@{}l@{}}Bool\\ Array\end{tabular}} & REAL       & \multicolumn{1}{l|}{\begin{tabular}[c]{@{}l@{}}( arraytype :ndims :layout \\ ( int32 ctype: real ) )\end{tabular}}      & \multicolumn{1}{c|}{VrArrayB}    \\ \hline

\end{tabular}
\caption[ArrayTypeTable]{ArrayType map. The table shows the VrArray types the ArrayTypes in VRIR are mapped to.}
\label{tab:arrayTypeMap}
\end{table}
\section{Operators}
\section{VrArrays}
\section{Statements}
\subsection{Assignment statement}
\subsection{For Statement}
\section{Basic Indexing}
\subsection{ Generating single index value from multiple indices}
\subsection{negative indexing}
\section{Advanced indexing}
\subsection{VrIndex}
\subsection{Array Slicing}
