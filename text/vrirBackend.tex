An important contribution of the thesis is the static generation of C++ code from VRIR. Due to differences in the semantics of VRIR and C++, we faced various challenges during code generation. As described in \chapref{chap:Background}, VRIR is a high level strongly typed AST designed to support easy compilation of a wide range of Array based languages. Hence, it supports different indexing schemes such as 0-indexing, 1-indexing and negative indexing as well as different array layout schemes such as row-major and column-major. C++ on the other hand does not have an built in support for arrays, and only supports 0-indexing and a row major layout. Moreover, VRIR also supports multiple returns. On the other hand, we can only return a single value, which can be a scalar, class, struct or a pointer, in C++. This chapter describes how different nodes in VRIR are mapped to C++ constructs including those which C++ does not implicitly support.
\section{Mapping Types}
Data types in VRIR, known as VTypes, can be categorised into 5 types :
\subsection{Scalar Type}
The scalar type is used define the primitive data type.
Different types of Scalar values are Int32, Int64, Float32, Float64 and Bool.
The mapping of VTypes to different C++ types is shown in table \ref{tab:typeMap}.
\begin{table}[h]
\centering
\begin{tabular}{|c|c|c|c|}
\hline
\multicolumn{2}{|c|}{Scalar Type}                                                                 & \multirow{2}{*}{Real / Complex}  & \multirow{2}{*}{C++ types} \\ \cline{1-2}
Name                                         & S-Expression                                      &                              &                            \\ \hline
\multirow{2}{*}{Float32}                     & \multicolumn{1}{c|}{\multirow{2}{*}{( float32 )}} & REAL                         & float                        \\ \cline{3-4} 
                                             & \multicolumn{1}{c|}{}                             & \multicolumn{1}{c|}{COMPLEX} & float complex              \\ \hline
\multirow{2}{*}{Float64}                     & \multicolumn{1}{c|}{\multirow{2}{*}{( float64 )}} & REAL                         & double                       \\ \cline{3-4} 
                                             & \multicolumn{1}{c|}{}                             & \multicolumn{1}{c|}{COMPLEX} & double complex             \\ \hline
\multicolumn{1}{|c|}{\multirow{2}{*}{Int32}} & \multirow{2}{*}{( int32 )}                        & REAL                         & int                      \\ \cline{3-4} 
\multicolumn{1}{|c|}{}                       &                                                   & \multicolumn{1}{c|}{COMPLEX} & Not Supported                          \\ \hline
\multicolumn{1}{|c|}{\multirow{2}{*}{Int64}} & \multirow{2}{*}{( int64 )}                        & REAL                         & long                     \\ \cline{3-4} 
\multicolumn{1}{|c|}{}                       &                                                   & \multicolumn{1}{c|}{COMPLEX} & Not Supported                          \\ \hline
\multicolumn{1}{|c|}{\multirow{2}{*}{Bool}} & \multirow{2}{*}{( bool )}                        & REAL                         & bool                     \\ \cline{3-4} 
\multicolumn{1}{|c|}{}                       &                                                   & \multicolumn{1}{c|}{COMPLEX} & Not Supported                          \\ \hline
\end{tabular}
\caption[VType to C++ type mapping]{VType to C++ type mapping. The tables shows the different C++ will be mapped to from the VTypes.} 
\label{tab:typeMap}
\end{table}
\subsection{Array Types}
\begin{table}[htbp]
\centering
\begin{tabular}{|c|c|c|c|}
\hline
\multicolumn{3}{|c|}{Array Type}                                                                                                                                                                                  & \multirow{2}{*}{VrArray}         \\ \cline{1-3}
Name                                                                       & Real / Complex & S-expression                                                                                                            &                                  \\ \hline
\multirow{2}{*}{\begin{tabular}[c]{@{}c@{}}Float64\\ Array\end{tabular}}   & REAL       & \begin{tabular}[c]{@{}c@{}}( arraytype :ndims :layout \\ ( float64 :ctype complex) )\end{tabular}                       & VrArrayF64                       \\ \cline{2-4} 
                                                                           & COMPLEX    & \multicolumn{1}{l|}{\begin{tabular}[c]{@{}l@{}}( arraytype :ndims :layout \\ ( float64 :ctype complex) )\end{tabular}}  & \multicolumn{1}{c|}{VrArrayCF64} \\ \hline
\multirow{2}{*}{\begin{tabular}[c]{@{}c@{}}Float32 \\ Array\end{tabular}}  & REAL       & \begin{tabular}[c]{@{}c@{}}( arraytype :ndims \\ :layout \\ ( float32  ctype: real ) )\end{tabular}                     & VrArrayF32                       \\ \cline{2-4} 
                                                                           & COMPLEX    & \multicolumn{1}{l|}{\begin{tabular}[c]{@{}l@{}}( arraytype :ndims :layout \\ ( float32,ctype: complex ) )\end{tabular}} & \multicolumn{1}{l|}{VrArrayCF32} \\ \hline
\begin{tabular}[c]{@{}c@{}}Int32 \\ Array\end{tabular}                     & REAL       & \begin{tabular}[c]{@{}c@{}}( arraytype :ndims :layout \\ ( int32 ctype: real ) )\end{tabular}                           & VrArrayI32                       \\ \hline
\begin{tabular}[c]{@{}c@{}}Int64 \\ Array\end{tabular}                     & REAL       & \begin{tabular}[c]{@{}c@{}}( arraytype :ndims :layout \\ ( int32 ctype: real ) )\end{tabular}                           & VrArrayI64                       \\ \hline
\multicolumn{1}{|c|}{\begin{tabular}[c]{@{}l@{}}Bool\\ Array\end{tabular}} & REAL       & \multicolumn{1}{l|}{\begin{tabular}[c]{@{}l@{}}( arraytype :ndims :layout \\ ( int32 ctype: real ) )\end{tabular}}      & \multicolumn{1}{c|}{VrArrayB}    \\ \hline
\end{tabular}
\caption[Array Types]{ArrayType map. The table shows the VrArray types the ArrayTypes in VRIR are mapped to.}
\label{tab:arrayTypeMap}
\end{table}

\begin{table}[htbp]
\centering
\begin{tabular}{|c|c|}
\hline
VrArray Type & Data Field Type \\ \hline
VrArrayF64   & double          \\ \hline
VrArrayF32   & float           \\ \hline
VrArrayCF64  & double complex  \\ \hline
VrArrayCF32  & float complex  \\ \hline
VrArrayI64   & long            \\ \hline
VrArrayI32   & int             \\ \hline
VrArrayB     & bool            \\ \hline
\end{tabular}
\caption[Data field types of different VrArrays]{Data field types of different VrArrays. Table depicting the types of the data field for different VrArray types.}
\label{tab:arrayDataMap}
\end{table}

C++ does not implicitly define types for arrays. Hence, we implemented structs for arrays of all the data types supported by VRIR. We call the structs collectively as VrArrays. There are separate VrArrays for and real and complex arrays. The different VrArray types for real array are shown in table \ref{tab:arrayTypeMap}.
\subsubsection{VrArrays}
VrArrays are the structs used to represent arrays in the generated code. They contain a pointer to the data as well as other necessary information such as the number of dimensions and the size of each dimension. There are different VrArrays for different data types. The different VrArray types and the VRIR types from which they are mapped are given in table \ref{tab:arrayTypeMap}. The structure of the different VrArrays in given below. Each VrArray has a data field which is a pointer to the array data. The type of the data field depends on the type of the VrArray. For example, the type of VrArrayF64, which is used to represent an float64 array is double. 
There are separate VrArray types for complex and real arrays of the same type. All operations on arrays in the language runtime take VrArrays as input. This allows single parameter to be passed for array instead of passing the data, dimensions and number of dimensions separately. The full list of VrArrays and the types of their corresponding data fields is given in table \ref{tab:arrayDataMap}.
\begin{lstlisting}[language=c, label={vrArrayF64Struct}, caption={Structures of different VrArrays}]
typedef struct VrArrayF64{
  double *data;
  dim_type* dims;  
  int ndims;
}VrArrayF64;

typedef struct VrArrayCF64{
  double complex *data;
  dim_type* dims;  
  int ndims;
}VrArrayCF64;

typedef struct VrArrayF32{
  float *data;
  dim_type* dims;  
  int ndims;
}VrArrayF32;

typedef struct VrArrayCF32{
  float complex *data;
  dim_type* dims;  
  int ndims;
}VrArrayCF32;

typedef struct VrArrayI32{
  int *data;
  dim_type* dims;  
  int ndims;
}VrArrayI32;

typedef struct VrArrayI64{
  int *data;
  dim_type* dims;  
  int ndims;
}VrArrayI64;
\end{lstlisting}

\subsection{Void Type}
\begin{table}[htbp]
\centering
\begin{tabular}{|c|c|}
\hline
Void Type & Generated Void \\ \hline
( void)   & void           \\ \hline
\end{tabular}
\caption[voidTypeMapping]{The table describes the generated C++ code for a void type.}
\label{tab:voidTypeMap}
\end{table}
The void type is used in most cases inside a Func Type to convey the absence of either input or output parameters. The void type is mapped to a simple `void' in C++. Table \ref{tab:voidTypeMap} shows the mapping
\subsection{Tuple Type}
Tuple types are used to define data structures which can have data of different types. While generating C++ code, the tuple types are used to generate structs that are in turn used to support data structures containing heteregenous data.% Table gives an example of a tuple type and the equivalent C++ struct that is generated.
\subsection{Func Type}
Func types are associated with function definitions and function handles. They contain information about the types of the input and out parameters of the function. The function types are for generating function definition.
A Func type and its equivalent function definition is shown in table \ref{tab:funcTypeMap}
\begin{table}[h]
\begin{tabular}{|l|l|}
\hline
\multicolumn{1}{|c|}{Func Type}                                                                                                                                                                                                                                       & \multicolumn{1}{c|}{Generated Function}                                                          \\ \hline
\begin{tabular}[c]{@{}l@{}}(functype\\ (intypes \\ ( arraytype :layout colmajor :ndims 2 \\  (float64 :ctype 0))\\  ( arraytype :layout colmajor :ndims 2 \\ (float64 :ctype 0))) \\ (outtypes \\ ( arraytype :layout colmajor :ndims 2 \\ (float64 :ctype 0))))\end{tabular} & \begin{tabular}[c]{@{}l@{}}VrArrayPtrF64 \\ babai (VrArrayPtrF64 R,VrArrayPtrF64 y)\end{tabular} \\ \hline
\end{tabular}
\caption[funcTypeMap]{The table shows an example func type and the equivalent function signature that was generated using the func type.}
\label{tab:funcTypeMap}
\end{table}
\section{Operators}
\label{sec:operators}
Arithemetic operators in VRIR, such as plus, minus, mult, div can only have scalar operands. Hence generating C++ code these operators in straightforward. They are mapped to the operators internally supported by C++. Thus plus is mapped to the `+' operator in C++, minus is mapped to `-'. The complete list is given in table \ref{tab:opMap}. \\
\begin{table}[h]
\centering
\begin{tabular}{|c|c|}
\hline
VRIR operators & C++ Operators \\ \hline
plus           & +             \\ \hline
minus          & -             \\ \hline
mult           & *             \\ \hline
div            & /             \\ \hline
and            & \&\&           \\ \hline
or             & ||            \\ \hline
lt             & \textless     \\ \hline
leq            & \textless=    \\ \hline
gt             & \textgreater  \\ \hline
geq            & \textgreater= \\ \hline
eq             & ==            \\ \hline
neq            & !=            \\ \hline
\end{tabular}
\caption[opMap]{VRIR operators to C++ operators Mapping. The table shows the C++ operators to which the VRIR operators are mapped.}
\label{tab:opMap}
\end{table}
Operations on arrays, on the other hand, are mapped to the LibCall expression in VRIR. Since C++ does not have internal operators for arrays we implemented function to support these operations on arrays. These functions are housed inside the language-specific runtime library. Where ever possible these functions made calls to BLAS functions for enchanced performance. In case of the \matlab\cite{matlab} runtime, we use the Intel Math Kernel Library\cite{mkl} or MKL implementation of BLAS and in case of Python\cite{python}, we use the openBLAS\cite{openblas} implementation.
\begin{table}[h]
\centering
\begin{tabular}{|c|c|c|c|}
\hline
VRIR Lib Call                               & Operand 1 & Operand 2 & C++ function \\ \hline
\multirow{2}{*}{Matrix Multiplication}      & Array     & Array     & mmult        \\ \cline{2-4} 
                                            & Array     & Scalar    & scal\_mult   \\ \hline
\multirow{2}{*}{Elementwise Multiplication} & Array     & Array     & vec\_mult    \\ \cline{2-4} 
                                            & Array     & Scalar    & scal\_mult   \\ \hline
\multirow{2}{*}{Matrix Left Division}       & Array     & Array     & mat\_ldiv    \\ \cline{2-4} 
                                            & Array     & Scalar    & scal\_div    \\ \hline
\multirow{2}{*}{Matrix Right Division}      & Array     & Array     & mat\_rdiv    \\ \cline{2-4} 
                                            & Array     & Scalar    & scal\_div    \\ \hline
\multirow{2}{*}{Elementwise Division}       & Array     & Array     & elem\_div    \\ \cline{2-4} 
                                            & Array     & Scalar    & scal\_div    \\ \hline
\multirow{2}{*}{Array Addition}             & Array     & Array     & vec\_add     \\ \cline{2-4} 
                                            & Array     & Scalar    & scal\_add    \\ \hline
\multirow{2}{*}{Array Subtraction}          & Array     & Array     & vec\_sub     \\ \cline{2-4} 
                                            & Array     & Scalar    & scal\_minus  \\ \hline
Array Copy                                  & Array     & Array     & vec\_copy    \\ \hline
Matrix Transpose                            & Array     & -         & transpose    \\ \hline
\end{tabular}
\caption[List of operations on Arrays]{The table shows the different C++ functions array operators are mapped to. }
\label{tab:arrayOpMap}
\end{table}
\section{Functions} 
\section{Statements}
\subsection{Assignment statement}
\subsection{For Statement}
\section{Basic Indexing}
\subsection{ Generating a single index value from multiple indices}
\subsection{Negative Indexing}
\section{Advanced Indexing}
\subsection{VrIndex}
\subsection{Array Slicing}
